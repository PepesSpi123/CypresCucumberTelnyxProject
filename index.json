{
  "stats": {
    "suites": 87,
    "tests": 147,
    "passes": 130,
    "pending": 0,
    "failures": 17,
    "start": "2022-12-20T19:48:16.807Z",
    "end": "2022-12-29T17:52:54.441Z",
    "duration": 2090795,
    "testsRegistered": 147,
    "passPercent": 88.43537414965986,
    "pendingPercent": 0,
    "other": 0,
    "hasOther": false,
    "skipped": 0,
    "hasSkipped": false
  },
  "results": [
    {
      "uuid": "6d1f7b48-f0d5-4bb9-a429-657049803faa",
      "title": "",
      "fullFile": "cypress/e2e/tests/twitter.feature",
      "file": "cypress/e2e/tests/twitter.feature",
      "beforeHooks": [],
      "afterHooks": [],
      "tests": [],
      "suites": [
        {
          "uuid": "887c8b8f-66a0-461e-843e-a07cca3e5803",
          "title": "telnyx.com",
          "fullFile": "",
          "file": "",
          "beforeHooks": [],
          "afterHooks": [],
          "tests": [
            {
              "title": "A15 -  Сhecking the functionality of the \"LinkedIn\" reference on the main page",
              "fullTitle": "telnyx.com A15 -  Сhecking the functionality of the \"LinkedIn\" reference on the main page",
              "timedOut": null,
              "duration": 20955,
              "state": "passed",
              "speed": "slow",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {},
              "uuid": "ba84366a-f282-4bdf-b5f6-acb377a23b4f",
              "parentUUID": "887c8b8f-66a0-461e-843e-a07cca3e5803",
              "isHook": false,
              "skipped": false
            }
          ],
          "suites": [],
          "passes": [
            "ba84366a-f282-4bdf-b5f6-acb377a23b4f"
          ],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 20955,
          "root": false,
          "rootEmpty": false,
          "_timeout": 2000
        }
      ],
      "passes": [],
      "failures": [],
      "pending": [],
      "skipped": [],
      "duration": 0,
      "root": true,
      "rootEmpty": true,
      "_timeout": 2000
    },
    {
      "uuid": "2e3b1f7a-ab99-4ca4-a319-1d8996e1ffe0",
      "title": "",
      "fullFile": "cypress/e2e/tests/10.feature",
      "file": "cypress/e2e/tests/10.feature",
      "beforeHooks": [],
      "afterHooks": [],
      "tests": [],
      "suites": [
        {
          "uuid": "691c8e4e-29fe-42fc-83c4-772fd5fca09c",
          "title": "telnyx.com",
          "fullFile": "",
          "file": "",
          "beforeHooks": [],
          "afterHooks": [],
          "tests": [
            {
              "title": "Checking the ability to go to the sign up page from the login page",
              "fullTitle": "telnyx.com Checking the ability to go to the sign up page from the login page",
              "timedOut": null,
              "duration": 55319,
              "state": "passed",
              "speed": "slow",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {},
              "uuid": "64c8e7b9-7c85-4d3e-baba-dd84007d8680",
              "parentUUID": "691c8e4e-29fe-42fc-83c4-772fd5fca09c",
              "isHook": false,
              "skipped": false
            }
          ],
          "suites": [],
          "passes": [
            "64c8e7b9-7c85-4d3e-baba-dd84007d8680"
          ],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 55319,
          "root": false,
          "rootEmpty": false,
          "_timeout": 2000
        }
      ],
      "passes": [],
      "failures": [],
      "pending": [],
      "skipped": [],
      "duration": 0,
      "root": true,
      "rootEmpty": true,
      "_timeout": 2000
    },
    {
      "uuid": "e573a4cb-53f7-4aed-9f69-f6ffa2f44a70",
      "title": "",
      "fullFile": "cypress/e2e/tests/11.feature",
      "file": "cypress/e2e/tests/11.feature",
      "beforeHooks": [],
      "afterHooks": [],
      "tests": [],
      "suites": [
        {
          "uuid": "d1029872-ded4-421d-80da-36a3298fa5f5",
          "title": "telnyx.com",
          "fullFile": "",
          "file": "",
          "beforeHooks": [],
          "afterHooks": [],
          "tests": [
            {
              "title": "Checking the ability to go to the login page from the sign up page",
              "fullTitle": "telnyx.com Checking the ability to go to the login page from the sign up page",
              "timedOut": null,
              "duration": 49219,
              "state": "passed",
              "speed": "slow",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {},
              "uuid": "d109063f-6746-4def-9074-d4049d5085d5",
              "parentUUID": "d1029872-ded4-421d-80da-36a3298fa5f5",
              "isHook": false,
              "skipped": false
            }
          ],
          "suites": [],
          "passes": [
            "d109063f-6746-4def-9074-d4049d5085d5"
          ],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 49219,
          "root": false,
          "rootEmpty": false,
          "_timeout": 2000
        }
      ],
      "passes": [],
      "failures": [],
      "pending": [],
      "skipped": [],
      "duration": 0,
      "root": true,
      "rootEmpty": true,
      "_timeout": 2000
    },
    {
      "uuid": "99506b96-e675-4cb0-8836-54c6790fb634",
      "title": "",
      "fullFile": "cypress/e2e/tests/12.feature",
      "file": "cypress/e2e/tests/12.feature",
      "beforeHooks": [],
      "afterHooks": [],
      "tests": [],
      "suites": [
        {
          "uuid": "f0e0f691-1455-4ae6-9bd8-0511187527cc",
          "title": "telnyx.com",
          "fullFile": "",
          "file": "",
          "beforeHooks": [],
          "afterHooks": [],
          "tests": [
            {
              "title": "Checking the ability to switch customers' comments",
              "fullTitle": "telnyx.com Checking the ability to switch customers' comments",
              "timedOut": null,
              "duration": 15312,
              "state": "passed",
              "speed": "slow",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {},
              "uuid": "2b207472-bb3f-4156-9377-70d3a7e9f88d",
              "parentUUID": "f0e0f691-1455-4ae6-9bd8-0511187527cc",
              "isHook": false,
              "skipped": false
            }
          ],
          "suites": [],
          "passes": [
            "2b207472-bb3f-4156-9377-70d3a7e9f88d"
          ],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 15312,
          "root": false,
          "rootEmpty": false,
          "_timeout": 2000
        }
      ],
      "passes": [],
      "failures": [],
      "pending": [],
      "skipped": [],
      "duration": 0,
      "root": true,
      "rootEmpty": true,
      "_timeout": 2000
    },
    {
      "uuid": "306c2a50-0364-4ecf-9628-beb2a4b000a0",
      "title": "",
      "fullFile": "cypress/e2e/tests/13.feature",
      "file": "cypress/e2e/tests/13.feature",
      "beforeHooks": [],
      "afterHooks": [],
      "tests": [],
      "suites": [
        {
          "uuid": "ec3eedef-6b7c-453f-a3df-64fb5c15a4a0",
          "title": "telnyx.com",
          "fullFile": "",
          "file": "",
          "beforeHooks": [],
          "afterHooks": [],
          "tests": [
            {
              "title": "Checking the ability to go to the sign up page from 'Switch + Save with Tenlyx' section",
              "fullTitle": "telnyx.com Checking the ability to go to the sign up page from 'Switch + Save with Tenlyx' section",
              "timedOut": null,
              "duration": 26607,
              "state": "passed",
              "speed": "slow",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {},
              "uuid": "015c9343-b7ce-46b7-85b4-64b39d526e7d",
              "parentUUID": "ec3eedef-6b7c-453f-a3df-64fb5c15a4a0",
              "isHook": false,
              "skipped": false
            }
          ],
          "suites": [],
          "passes": [
            "015c9343-b7ce-46b7-85b4-64b39d526e7d"
          ],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 26607,
          "root": false,
          "rootEmpty": false,
          "_timeout": 2000
        }
      ],
      "passes": [],
      "failures": [],
      "pending": [],
      "skipped": [],
      "duration": 0,
      "root": true,
      "rootEmpty": true,
      "_timeout": 2000
    },
    {
      "uuid": "046689a8-d114-402f-87a8-6234edd2efd0",
      "title": "",
      "fullFile": "cypress/e2e/tests/14.feature",
      "file": "cypress/e2e/tests/14.feature",
      "beforeHooks": [],
      "afterHooks": [],
      "tests": [],
      "suites": [
        {
          "uuid": "0a974148-0fc6-4883-b2a5-683169b1b7ee",
          "title": "telnyx.com",
          "fullFile": "",
          "file": "",
          "beforeHooks": [],
          "afterHooks": [],
          "tests": [
            {
              "title": "Checking the ability to go to the sign up page from footer",
              "fullTitle": "telnyx.com Checking the ability to go to the sign up page from footer",
              "timedOut": null,
              "duration": 23984,
              "state": "passed",
              "speed": "slow",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {},
              "uuid": "f2f3dfb3-1593-4c44-860f-73531778ecd1",
              "parentUUID": "0a974148-0fc6-4883-b2a5-683169b1b7ee",
              "isHook": false,
              "skipped": false
            }
          ],
          "suites": [],
          "passes": [
            "f2f3dfb3-1593-4c44-860f-73531778ecd1"
          ],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 23984,
          "root": false,
          "rootEmpty": false,
          "_timeout": 2000
        }
      ],
      "passes": [],
      "failures": [],
      "pending": [],
      "skipped": [],
      "duration": 0,
      "root": true,
      "rootEmpty": true,
      "_timeout": 2000
    },
    {
      "uuid": "96d0b9a3-028f-4e7a-9c45-f9dce9c2e635",
      "title": "",
      "fullFile": "cypress/e2e/tests/15.feature",
      "file": "cypress/e2e/tests/15.feature",
      "beforeHooks": [],
      "afterHooks": [],
      "tests": [],
      "suites": [
        {
          "uuid": "8c616006-c28c-41df-8ddc-95f37ca9a7fa",
          "title": "telnyx.com",
          "fullFile": "",
          "file": "",
          "beforeHooks": [],
          "afterHooks": [],
          "tests": [
            {
              "title": "Check that the site is linked with Twitter",
              "fullTitle": "telnyx.com Check that the site is linked with Twitter",
              "timedOut": null,
              "duration": 16521,
              "state": "passed",
              "speed": "slow",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {},
              "uuid": "04a40af9-88fa-4dc6-a66d-72d591f23889",
              "parentUUID": "8c616006-c28c-41df-8ddc-95f37ca9a7fa",
              "isHook": false,
              "skipped": false
            }
          ],
          "suites": [],
          "passes": [
            "04a40af9-88fa-4dc6-a66d-72d591f23889"
          ],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 16521,
          "root": false,
          "rootEmpty": false,
          "_timeout": 2000
        }
      ],
      "passes": [],
      "failures": [],
      "pending": [],
      "skipped": [],
      "duration": 0,
      "root": true,
      "rootEmpty": true,
      "_timeout": 2000
    },
    {
      "uuid": "578bff16-f1a8-467d-bfa8-abec6c81c2e1",
      "title": "",
      "fullFile": "cypress/e2e/tests/2.feature",
      "file": "cypress/e2e/tests/2.feature",
      "beforeHooks": [],
      "afterHooks": [],
      "tests": [],
      "suites": [
        {
          "uuid": "52efc74a-b866-49b3-b96c-44721eb9b2b2",
          "title": "telnyx.com",
          "fullFile": "",
          "file": "",
          "beforeHooks": [],
          "afterHooks": [],
          "tests": [
            {
              "title": "Checking that it is possible to see all products by the main page",
              "fullTitle": "telnyx.com Checking that it is possible to see all products by the main page",
              "timedOut": null,
              "duration": 13687,
              "state": "passed",
              "speed": "slow",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {},
              "uuid": "187102cb-afb3-4ed5-b554-b5d34e503771",
              "parentUUID": "52efc74a-b866-49b3-b96c-44721eb9b2b2",
              "isHook": false,
              "skipped": false
            }
          ],
          "suites": [],
          "passes": [
            "187102cb-afb3-4ed5-b554-b5d34e503771"
          ],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 13687,
          "root": false,
          "rootEmpty": false,
          "_timeout": 2000
        }
      ],
      "passes": [],
      "failures": [],
      "pending": [],
      "skipped": [],
      "duration": 0,
      "root": true,
      "rootEmpty": true,
      "_timeout": 2000
    },
    {
      "uuid": "9d279bb6-dafc-4b6b-9fa8-2071fc67642c",
      "title": "",
      "fullFile": "cypress/e2e/tests/3.feature",
      "file": "cypress/e2e/tests/3.feature",
      "beforeHooks": [],
      "afterHooks": [],
      "tests": [],
      "suites": [
        {
          "uuid": "e069ad86-b668-4422-9fab-f3e65f370def",
          "title": "telnyx.com",
          "fullFile": "",
          "file": "",
          "beforeHooks": [],
          "afterHooks": [],
          "tests": [
            {
              "title": "Checking that it is possible to see all products by the footer",
              "fullTitle": "telnyx.com Checking that it is possible to see all products by the footer",
              "timedOut": null,
              "duration": 15189,
              "state": "passed",
              "speed": "slow",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {},
              "uuid": "e40c5c80-540c-4228-a137-91481785e86b",
              "parentUUID": "e069ad86-b668-4422-9fab-f3e65f370def",
              "isHook": false,
              "skipped": false
            }
          ],
          "suites": [],
          "passes": [
            "e40c5c80-540c-4228-a137-91481785e86b"
          ],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 15189,
          "root": false,
          "rootEmpty": false,
          "_timeout": 2000
        }
      ],
      "passes": [],
      "failures": [],
      "pending": [],
      "skipped": [],
      "duration": 0,
      "root": true,
      "rootEmpty": true,
      "_timeout": 2000
    },
    {
      "uuid": "efd542dc-d965-4489-b639-b7c33bd33c17",
      "title": "",
      "fullFile": "cypress/e2e/tests/4.feature",
      "file": "cypress/e2e/tests/4.feature",
      "beforeHooks": [],
      "afterHooks": [],
      "tests": [],
      "suites": [
        {
          "uuid": "bc31ee3c-1c20-40f1-afd6-4fff17c20b37",
          "title": "telnyx.com",
          "fullFile": "",
          "file": "",
          "beforeHooks": [],
          "afterHooks": [],
          "tests": [
            {
              "title": "Checking the ability to read customers stories",
              "fullTitle": "telnyx.com Checking the ability to read customers stories",
              "timedOut": null,
              "duration": 18122,
              "state": "passed",
              "speed": "slow",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {},
              "uuid": "a5d16bf6-1d64-41b6-83a9-235833faaa4a",
              "parentUUID": "bc31ee3c-1c20-40f1-afd6-4fff17c20b37",
              "isHook": false,
              "skipped": false
            }
          ],
          "suites": [],
          "passes": [
            "a5d16bf6-1d64-41b6-83a9-235833faaa4a"
          ],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 18122,
          "root": false,
          "rootEmpty": false,
          "_timeout": 2000
        }
      ],
      "passes": [],
      "failures": [],
      "pending": [],
      "skipped": [],
      "duration": 0,
      "root": true,
      "rootEmpty": true,
      "_timeout": 2000
    },
    {
      "uuid": "35487a93-7afe-477a-9ebe-1bf669c5017a",
      "title": "",
      "fullFile": "cypress/e2e/tests/5.feature",
      "file": "cypress/e2e/tests/5.feature",
      "beforeHooks": [],
      "afterHooks": [],
      "tests": [],
      "suites": [
        {
          "uuid": "a2cbc29e-01ff-4607-ae47-b096ba5689a0",
          "title": "telnyx.com",
          "fullFile": "",
          "file": "",
          "beforeHooks": [],
          "afterHooks": [],
          "tests": [
            {
              "title": "Checking the ability to  change data by slider",
              "fullTitle": "telnyx.com Checking the ability to  change data by slider",
              "timedOut": null,
              "duration": 36143,
              "state": "passed",
              "speed": "slow",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {},
              "uuid": "51fb90c7-cbdf-4951-b00c-453ca986c793",
              "parentUUID": "a2cbc29e-01ff-4607-ae47-b096ba5689a0",
              "isHook": false,
              "skipped": false
            }
          ],
          "suites": [],
          "passes": [
            "51fb90c7-cbdf-4951-b00c-453ca986c793"
          ],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 36143,
          "root": false,
          "rootEmpty": false,
          "_timeout": 2000
        }
      ],
      "passes": [],
      "failures": [],
      "pending": [],
      "skipped": [],
      "duration": 0,
      "root": true,
      "rootEmpty": true,
      "_timeout": 2000
    },
    {
      "uuid": "ecf5d8a5-1dcd-4103-a6cf-5ae51bbdf24d",
      "title": "",
      "fullFile": "cypress/e2e/tests/6.feature",
      "file": "cypress/e2e/tests/6.feature",
      "beforeHooks": [],
      "afterHooks": [],
      "tests": [],
      "suites": [
        {
          "uuid": "2767aa99-ac49-4bd2-be76-0606e2839fb4",
          "title": "telnyx.com",
          "fullFile": "",
          "file": "",
          "beforeHooks": [],
          "afterHooks": [],
          "tests": [
            {
              "title": "Checking the ability to change data and look at the current price",
              "fullTitle": "telnyx.com Checking the ability to change data and look at the current price",
              "timedOut": null,
              "duration": 35402,
              "state": "passed",
              "speed": "slow",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {},
              "uuid": "e60bd726-a954-4d13-8e6b-cc1443ffd794",
              "parentUUID": "2767aa99-ac49-4bd2-be76-0606e2839fb4",
              "isHook": false,
              "skipped": false
            }
          ],
          "suites": [],
          "passes": [
            "e60bd726-a954-4d13-8e6b-cc1443ffd794"
          ],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 35402,
          "root": false,
          "rootEmpty": false,
          "_timeout": 2000
        }
      ],
      "passes": [],
      "failures": [],
      "pending": [],
      "skipped": [],
      "duration": 0,
      "root": true,
      "rootEmpty": true,
      "_timeout": 2000
    },
    {
      "uuid": "b3facfd2-dcac-43c4-bf9d-c0b3250a97f3",
      "title": "",
      "fullFile": "cypress/e2e/tests/7.feature",
      "file": "cypress/e2e/tests/7.feature",
      "beforeHooks": [],
      "afterHooks": [],
      "tests": [],
      "suites": [
        {
          "uuid": "b811f1c3-2bfb-4831-ae32-b0074652153c",
          "title": "telnyx.com",
          "fullFile": "",
          "file": "",
          "beforeHooks": [],
          "afterHooks": [],
          "tests": [
            {
              "title": "Checking the ability to see how much money will be save up",
              "fullTitle": "telnyx.com Checking the ability to see how much money will be save up",
              "timedOut": null,
              "duration": 35699,
              "state": "passed",
              "speed": "slow",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {},
              "uuid": "2b58bc62-5d4c-4c37-af86-2da74ea00e3e",
              "parentUUID": "b811f1c3-2bfb-4831-ae32-b0074652153c",
              "isHook": false,
              "skipped": false
            }
          ],
          "suites": [],
          "passes": [
            "2b58bc62-5d4c-4c37-af86-2da74ea00e3e"
          ],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 35699,
          "root": false,
          "rootEmpty": false,
          "_timeout": 2000
        }
      ],
      "passes": [],
      "failures": [],
      "pending": [],
      "skipped": [],
      "duration": 0,
      "root": true,
      "rootEmpty": true,
      "_timeout": 2000
    },
    {
      "uuid": "4d920470-7878-4614-92d7-8926b53c8e35",
      "title": "",
      "fullFile": "cypress/e2e/tests/8.feature",
      "file": "cypress/e2e/tests/8.feature",
      "beforeHooks": [],
      "afterHooks": [],
      "tests": [],
      "suites": [
        {
          "uuid": "f400f277-f324-4cd2-86a4-52b2cbcdff42",
          "title": "telnyx.com",
          "fullFile": "",
          "file": "",
          "beforeHooks": [],
          "afterHooks": [],
          "tests": [
            {
              "title": "Checking the ability to switch customers' comments",
              "fullTitle": "telnyx.com Checking the ability to switch customers' comments",
              "timedOut": null,
              "duration": 8061,
              "state": "passed",
              "speed": "medium",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {},
              "uuid": "e29ab107-26f1-4cea-a189-1548d478dca9",
              "parentUUID": "f400f277-f324-4cd2-86a4-52b2cbcdff42",
              "isHook": false,
              "skipped": false
            }
          ],
          "suites": [],
          "passes": [
            "e29ab107-26f1-4cea-a189-1548d478dca9"
          ],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 8061,
          "root": false,
          "rootEmpty": false,
          "_timeout": 2000
        }
      ],
      "passes": [],
      "failures": [],
      "pending": [],
      "skipped": [],
      "duration": 0,
      "root": true,
      "rootEmpty": true,
      "_timeout": 2000
    },
    {
      "uuid": "3834966f-98a4-4fa3-bcdc-defbaefa240a",
      "title": "",
      "fullFile": "cypress/e2e/tests/9.feature",
      "file": "cypress/e2e/tests/9.feature",
      "beforeHooks": [],
      "afterHooks": [],
      "tests": [],
      "suites": [
        {
          "uuid": "166ac632-69ba-4bc7-a0e7-399f1a0a9f24",
          "title": "telnyx.com",
          "fullFile": "",
          "file": "",
          "beforeHooks": [],
          "afterHooks": [],
          "tests": [
            {
              "title": "Checking the ability to learn more about API documentation",
              "fullTitle": "telnyx.com Checking the ability to learn more about API documentation",
              "timedOut": null,
              "duration": 16859,
              "state": "passed",
              "speed": "slow",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {},
              "uuid": "4e499ec1-67c2-4078-a6dc-2ed4f0f82583",
              "parentUUID": "166ac632-69ba-4bc7-a0e7-399f1a0a9f24",
              "isHook": false,
              "skipped": false
            }
          ],
          "suites": [],
          "passes": [
            "4e499ec1-67c2-4078-a6dc-2ed4f0f82583"
          ],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 16859,
          "root": false,
          "rootEmpty": false,
          "_timeout": 2000
        }
      ],
      "passes": [],
      "failures": [],
      "pending": [],
      "skipped": [],
      "duration": 0,
      "root": true,
      "rootEmpty": true,
      "_timeout": 2000
    },
    {
      "uuid": "aa62d3a2-9708-4f65-a16b-71aaeb335c3e",
      "title": "",
      "fullFile": "cypress/e2e/tests/API.feature",
      "file": "cypress/e2e/tests/API.feature",
      "beforeHooks": [],
      "afterHooks": [],
      "tests": [],
      "suites": [
        {
          "uuid": "2d1f1a6a-1e44-4ce5-b049-9e538773f4af",
          "title": "telnyx.com",
          "fullFile": "",
          "file": "",
          "beforeHooks": [],
          "afterHooks": [],
          "tests": [
            {
              "title": "A9 - Checking the ability to learn more about API documentation",
              "fullTitle": "telnyx.com A9 - Checking the ability to learn more about API documentation",
              "timedOut": null,
              "duration": 13691,
              "state": "passed",
              "speed": "slow",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {},
              "uuid": "206f4a9f-e1f3-4ae4-a660-6083cb45e1a4",
              "parentUUID": "2d1f1a6a-1e44-4ce5-b049-9e538773f4af",
              "isHook": false,
              "skipped": false
            }
          ],
          "suites": [],
          "passes": [
            "206f4a9f-e1f3-4ae4-a660-6083cb45e1a4"
          ],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 13691,
          "root": false,
          "rootEmpty": false,
          "_timeout": 2000
        }
      ],
      "passes": [],
      "failures": [],
      "pending": [],
      "skipped": [],
      "duration": 0,
      "root": true,
      "rootEmpty": true,
      "_timeout": 2000
    },
    {
      "uuid": "747ba635-0594-4f69-ad09-78da4d381eec",
      "title": "",
      "fullFile": "cypress/e2e/tests/API.feature",
      "file": "cypress/e2e/tests/API.feature",
      "beforeHooks": [],
      "afterHooks": [],
      "tests": [],
      "suites": [
        {
          "uuid": "a2501855-5993-4e1c-82d0-7d5c5f3eea01",
          "title": "telnyx.com",
          "fullFile": "",
          "file": "",
          "beforeHooks": [],
          "afterHooks": [],
          "tests": [
            {
              "title": "A9 - Checking the ability to learn more about API documentation",
              "fullTitle": "telnyx.com A9 - Checking the ability to learn more about API documentation",
              "timedOut": null,
              "duration": 39862,
              "state": "passed",
              "speed": "slow",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {},
              "uuid": "0e031f82-13ff-4cdc-a349-f750f7f6cb8d",
              "parentUUID": "a2501855-5993-4e1c-82d0-7d5c5f3eea01",
              "isHook": false,
              "skipped": false
            }
          ],
          "suites": [],
          "passes": [
            "0e031f82-13ff-4cdc-a349-f750f7f6cb8d"
          ],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 39862,
          "root": false,
          "rootEmpty": false,
          "_timeout": 2000
        }
      ],
      "passes": [],
      "failures": [],
      "pending": [],
      "skipped": [],
      "duration": 0,
      "root": true,
      "rootEmpty": true,
      "_timeout": 2000
    },
    {
      "uuid": "bf390450-deb7-4f25-beed-7b2062f90997",
      "title": "",
      "fullFile": "cypress/e2e/tests/comments.feature",
      "file": "cypress/e2e/tests/comments.feature",
      "beforeHooks": [],
      "afterHooks": [],
      "tests": [],
      "suites": [
        {
          "uuid": "45684055-9496-49fa-9121-ef4770f17ae1",
          "title": "telnyx.com",
          "fullFile": "",
          "file": "",
          "beforeHooks": [],
          "afterHooks": [],
          "tests": [
            {
              "title": "A8 - Checking the ability to switch customers' comments",
              "fullTitle": "telnyx.com A8 - Checking the ability to switch customers' comments",
              "timedOut": null,
              "duration": 5878,
              "state": "failed",
              "speed": null,
              "pass": false,
              "fail": true,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {
                "message": "Error: \nStep implementation missing for \"I scroll down to the customers' comments\".\n\nWe tried searching for files containing step definitions using the following search pattern templates:\n\n  - cypress/e2e/tests/[filepath]/**/*.{js,mjs,ts,tsx}\n  - cypress/e2e/tests/[filepath].{js,mjs,ts,tsx}\n  - cypress/support/step_definitions/**/*.{js,mjs,ts,tsx}\n\nThese templates resolved to the following search patterns:\n\n  - cypress/e2e/tests/comments/**/*.{js,mjs,ts,tsx}\n  - cypress/e2e/tests/comments.{js,mjs,ts,tsx}\n  - cypress/support/step_definitions/**/*.{js,mjs,ts,tsx}\n\nThese patterns matched the following files:\n\n  - cypress/e2e/tests/comments.js\n\nHowever, none of these files contained a step definition matching \"I scroll down to the customers' comments\".\n\nYou can implement it using the suggestion(s) below.\n\n  Given(\"I scroll down to the customers' comments\", function () {\n    return \"pending\";\n  });\n  ",
                "estack": "Error: \nStep implementation missing for \"I scroll down to the customers' comments\".\n\nWe tried searching for files containing step definitions using the following search pattern templates:\n\n  - cypress/e2e/tests/[filepath]/**/*.{js,mjs,ts,tsx}\n  - cypress/e2e/tests/[filepath].{js,mjs,ts,tsx}\n  - cypress/support/step_definitions/**/*.{js,mjs,ts,tsx}\n\nThese templates resolved to the following search patterns:\n\n  - cypress/e2e/tests/comments/**/*.{js,mjs,ts,tsx}\n  - cypress/e2e/tests/comments.{js,mjs,ts,tsx}\n  - cypress/support/step_definitions/**/*.{js,mjs,ts,tsx}\n\nThese patterns matched the following files:\n\n  - cypress/e2e/tests/comments.js\n\nHowever, none of these files contained a step definition matching \"I scroll down to the customers' comments\".\n\nYou can implement it using the suggestion(s) below.\n\n  Given(\"I scroll down to the customers' comments\", function () {\n    return \"pending\";\n  });\n  \n    at Context.eval (node_modules/@badeball/cypress-cucumber-preprocessor/lib/create-tests.js:300:0)",
                "diff": null
              },
              "uuid": "46598b08-5889-474f-93f8-5610f6753a5b",
              "parentUUID": "45684055-9496-49fa-9121-ef4770f17ae1",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "A12 - Checking the ability to switch customers' comments",
              "fullTitle": "telnyx.com A12 - Checking the ability to switch customers' comments",
              "timedOut": null,
              "duration": 7668,
              "state": "failed",
              "speed": null,
              "pass": false,
              "fail": true,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {
                "message": "Error: \nStep implementation missing for \"I scroll down to the customers' comments\".\n\nWe tried searching for files containing step definitions using the following search pattern templates:\n\n  - cypress/e2e/tests/[filepath]/**/*.{js,mjs,ts,tsx}\n  - cypress/e2e/tests/[filepath].{js,mjs,ts,tsx}\n  - cypress/support/step_definitions/**/*.{js,mjs,ts,tsx}\n\nThese templates resolved to the following search patterns:\n\n  - cypress/e2e/tests/comments/**/*.{js,mjs,ts,tsx}\n  - cypress/e2e/tests/comments.{js,mjs,ts,tsx}\n  - cypress/support/step_definitions/**/*.{js,mjs,ts,tsx}\n\nThese patterns matched the following files:\n\n  - cypress/e2e/tests/comments.js\n\nHowever, none of these files contained a step definition matching \"I scroll down to the customers' comments\".\n\nYou can implement it using the suggestion(s) below.\n\n  Given(\"I scroll down to the customers' comments\", function () {\n    return \"pending\";\n  });\n  ",
                "estack": "Error: \nStep implementation missing for \"I scroll down to the customers' comments\".\n\nWe tried searching for files containing step definitions using the following search pattern templates:\n\n  - cypress/e2e/tests/[filepath]/**/*.{js,mjs,ts,tsx}\n  - cypress/e2e/tests/[filepath].{js,mjs,ts,tsx}\n  - cypress/support/step_definitions/**/*.{js,mjs,ts,tsx}\n\nThese templates resolved to the following search patterns:\n\n  - cypress/e2e/tests/comments/**/*.{js,mjs,ts,tsx}\n  - cypress/e2e/tests/comments.{js,mjs,ts,tsx}\n  - cypress/support/step_definitions/**/*.{js,mjs,ts,tsx}\n\nThese patterns matched the following files:\n\n  - cypress/e2e/tests/comments.js\n\nHowever, none of these files contained a step definition matching \"I scroll down to the customers' comments\".\n\nYou can implement it using the suggestion(s) below.\n\n  Given(\"I scroll down to the customers' comments\", function () {\n    return \"pending\";\n  });\n  \n    at Context.eval (node_modules/@badeball/cypress-cucumber-preprocessor/lib/create-tests.js:300:0)",
                "diff": null
              },
              "uuid": "ae8f77e5-f599-4efc-9437-782b45200aed",
              "parentUUID": "45684055-9496-49fa-9121-ef4770f17ae1",
              "isHook": false,
              "skipped": false
            }
          ],
          "suites": [],
          "passes": [],
          "failures": [
            "46598b08-5889-474f-93f8-5610f6753a5b",
            "ae8f77e5-f599-4efc-9437-782b45200aed"
          ],
          "pending": [],
          "skipped": [],
          "duration": 13546,
          "root": false,
          "rootEmpty": false,
          "_timeout": 2000
        }
      ],
      "passes": [],
      "failures": [],
      "pending": [],
      "skipped": [],
      "duration": 0,
      "root": true,
      "rootEmpty": true,
      "_timeout": 2000
    },
    {
      "uuid": "ce330cb9-365c-4df8-9185-e6577ffdf39c",
      "title": "",
      "fullFile": "cypress/e2e/tests/API.feature",
      "file": "cypress/e2e/tests/API.feature",
      "beforeHooks": [],
      "afterHooks": [],
      "tests": [],
      "suites": [
        {
          "uuid": "9001bada-c811-4585-9b00-58a3a7a3915c",
          "title": "telnyx.com",
          "fullFile": "",
          "file": "",
          "beforeHooks": [],
          "afterHooks": [],
          "tests": [
            {
              "title": "A9 - Checking the ability to learn more about API documentation",
              "fullTitle": "telnyx.com A9 - Checking the ability to learn more about API documentation",
              "timedOut": null,
              "duration": 16089,
              "state": "passed",
              "speed": "slow",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {},
              "uuid": "319ab84f-26ea-4bf7-9bcc-5d44583d6401",
              "parentUUID": "9001bada-c811-4585-9b00-58a3a7a3915c",
              "isHook": false,
              "skipped": false
            }
          ],
          "suites": [],
          "passes": [
            "319ab84f-26ea-4bf7-9bcc-5d44583d6401"
          ],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 16089,
          "root": false,
          "rootEmpty": false,
          "_timeout": 2000
        }
      ],
      "passes": [],
      "failures": [],
      "pending": [],
      "skipped": [],
      "duration": 0,
      "root": true,
      "rootEmpty": true,
      "_timeout": 2000
    },
    {
      "uuid": "24c7b6cd-6d13-4a3e-93b7-91faaf076a25",
      "title": "",
      "fullFile": "cypress/e2e/tests/customerStory.feature",
      "file": "cypress/e2e/tests/customerStory.feature",
      "beforeHooks": [],
      "afterHooks": [],
      "tests": [],
      "suites": [
        {
          "uuid": "1a7e9c4b-7a56-421f-a118-2cb47e1ec084",
          "title": "telnyx.com",
          "fullFile": "",
          "file": "",
          "beforeHooks": [],
          "afterHooks": [],
          "tests": [
            {
              "title": "A4 - Checking the ability to read customers stories",
              "fullTitle": "telnyx.com A4 - Checking the ability to read customers stories",
              "timedOut": null,
              "duration": 7669,
              "state": "passed",
              "speed": "medium",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {},
              "uuid": "d84f9c51-d23c-4b23-ac54-dcb4fce9e8b4",
              "parentUUID": "1a7e9c4b-7a56-421f-a118-2cb47e1ec084",
              "isHook": false,
              "skipped": false
            }
          ],
          "suites": [],
          "passes": [
            "d84f9c51-d23c-4b23-ac54-dcb4fce9e8b4"
          ],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 7669,
          "root": false,
          "rootEmpty": false,
          "_timeout": 2000
        }
      ],
      "passes": [],
      "failures": [],
      "pending": [],
      "skipped": [],
      "duration": 0,
      "root": true,
      "rootEmpty": true,
      "_timeout": 2000
    },
    {
      "uuid": "4e549a07-5380-4017-aea8-bba53c8ffd6b",
      "title": "",
      "fullFile": "cypress/e2e/tests/comments.feature",
      "file": "cypress/e2e/tests/comments.feature",
      "beforeHooks": [],
      "afterHooks": [],
      "tests": [],
      "suites": [
        {
          "uuid": "db6d568f-4fde-4797-b24c-ff68f4488053",
          "title": "telnyx.com",
          "fullFile": "",
          "file": "",
          "beforeHooks": [],
          "afterHooks": [],
          "tests": [
            {
              "title": "A8 - Checking the ability to switch customers' comments",
              "fullTitle": "telnyx.com A8 - Checking the ability to switch customers' comments",
              "timedOut": null,
              "duration": 3989,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {},
              "uuid": "0caa7dae-eeb1-4a4a-8862-2297197d9df6",
              "parentUUID": "db6d568f-4fde-4797-b24c-ff68f4488053",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "A12 - Checking the ability to switch customers' comments",
              "fullTitle": "telnyx.com A12 - Checking the ability to switch customers' comments",
              "timedOut": null,
              "duration": 11216,
              "state": "passed",
              "speed": "slow",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {},
              "uuid": "77e88947-bdf3-42be-8393-0a04dc970fa9",
              "parentUUID": "db6d568f-4fde-4797-b24c-ff68f4488053",
              "isHook": false,
              "skipped": false
            }
          ],
          "suites": [],
          "passes": [
            "0caa7dae-eeb1-4a4a-8862-2297197d9df6",
            "77e88947-bdf3-42be-8393-0a04dc970fa9"
          ],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 15205,
          "root": false,
          "rootEmpty": false,
          "_timeout": 2000
        }
      ],
      "passes": [],
      "failures": [],
      "pending": [],
      "skipped": [],
      "duration": 0,
      "root": true,
      "rootEmpty": true,
      "_timeout": 2000
    },
    {
      "uuid": "b2521053-17b7-48fd-aa0f-69574e589adf",
      "title": "",
      "fullFile": "cypress/e2e/tests/goToLogin.feature",
      "file": "cypress/e2e/tests/goToLogin.feature",
      "beforeHooks": [],
      "afterHooks": [],
      "tests": [],
      "suites": [
        {
          "uuid": "0ce3ab37-893c-4e58-99ca-6039df1454be",
          "title": "telnyx.com",
          "fullFile": "",
          "file": "",
          "beforeHooks": [],
          "afterHooks": [],
          "tests": [
            {
              "title": "A11 - Checking the ability to go to the login page from the sign up page",
              "fullTitle": "telnyx.com A11 - Checking the ability to go to the login page from the sign up page",
              "timedOut": null,
              "duration": 21464,
              "state": "passed",
              "speed": "slow",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {},
              "uuid": "f8edee8d-eb19-4687-84f6-64728ab37580",
              "parentUUID": "0ce3ab37-893c-4e58-99ca-6039df1454be",
              "isHook": false,
              "skipped": false
            }
          ],
          "suites": [],
          "passes": [
            "f8edee8d-eb19-4687-84f6-64728ab37580"
          ],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 21464,
          "root": false,
          "rootEmpty": false,
          "_timeout": 2000
        }
      ],
      "passes": [],
      "failures": [],
      "pending": [],
      "skipped": [],
      "duration": 0,
      "root": true,
      "rootEmpty": true,
      "_timeout": 2000
    },
    {
      "uuid": "37c860a5-149b-4d31-9f57-308976fedac9",
      "title": "",
      "fullFile": "cypress/e2e/tests/goToLogin.feature",
      "file": "cypress/e2e/tests/goToLogin.feature",
      "beforeHooks": [],
      "afterHooks": [],
      "tests": [],
      "suites": [
        {
          "uuid": "78748c68-d64c-44c1-93b3-0a18fea353ae",
          "title": "telnyx.com",
          "fullFile": "",
          "file": "",
          "beforeHooks": [],
          "afterHooks": [],
          "tests": [
            {
              "title": "A11 - Checking the ability to go to the login page from the sign up page",
              "fullTitle": "telnyx.com A11 - Checking the ability to go to the login page from the sign up page",
              "timedOut": null,
              "duration": 21548,
              "state": "passed",
              "speed": "slow",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {},
              "uuid": "4bcfb05e-d924-4155-8b47-4d206f278412",
              "parentUUID": "78748c68-d64c-44c1-93b3-0a18fea353ae",
              "isHook": false,
              "skipped": false
            }
          ],
          "suites": [],
          "passes": [
            "4bcfb05e-d924-4155-8b47-4d206f278412"
          ],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 21548,
          "root": false,
          "rootEmpty": false,
          "_timeout": 2000
        }
      ],
      "passes": [],
      "failures": [],
      "pending": [],
      "skipped": [],
      "duration": 0,
      "root": true,
      "rootEmpty": true,
      "_timeout": 2000
    },
    {
      "uuid": "de5e2dbe-8388-4734-9b68-85c89477b3fc",
      "title": "",
      "fullFile": "cypress/e2e/tests/goToSignUp.feature",
      "file": "cypress/e2e/tests/goToSignUp.feature",
      "beforeHooks": [],
      "afterHooks": [],
      "tests": [],
      "suites": [
        {
          "uuid": "80a64a10-a767-4dab-b7d3-ef6962f8834a",
          "title": "telnyx.com",
          "fullFile": "",
          "file": "",
          "beforeHooks": [],
          "afterHooks": [],
          "tests": [
            {
              "title": "A10 - Checking the ability to go to the sign up page from the login page",
              "fullTitle": "telnyx.com A10 - Checking the ability to go to the sign up page from the login page",
              "timedOut": null,
              "duration": 22063,
              "state": "passed",
              "speed": "slow",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {},
              "uuid": "174d925d-0ddd-4cbc-9fe4-e94926364363",
              "parentUUID": "80a64a10-a767-4dab-b7d3-ef6962f8834a",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "A14 - Checking the ability to go to the sign up page from footer",
              "fullTitle": "telnyx.com A14 - Checking the ability to go to the sign up page from footer",
              "timedOut": null,
              "duration": 6076,
              "state": "passed",
              "speed": "medium",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {},
              "uuid": "da34a1a5-427b-4b90-83de-f7dabe4c5656",
              "parentUUID": "80a64a10-a767-4dab-b7d3-ef6962f8834a",
              "isHook": false,
              "skipped": false
            }
          ],
          "suites": [],
          "passes": [
            "174d925d-0ddd-4cbc-9fe4-e94926364363",
            "da34a1a5-427b-4b90-83de-f7dabe4c5656"
          ],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 28139,
          "root": false,
          "rootEmpty": false,
          "_timeout": 2000
        }
      ],
      "passes": [],
      "failures": [],
      "pending": [],
      "skipped": [],
      "duration": 0,
      "root": true,
      "rootEmpty": true,
      "_timeout": 2000
    },
    {
      "uuid": "8f3633de-8db1-4d18-8c72-bf9c5a5caede",
      "title": "",
      "fullFile": "cypress/e2e/tests/goToSignUp.feature",
      "file": "cypress/e2e/tests/goToSignUp.feature",
      "beforeHooks": [],
      "afterHooks": [],
      "tests": [],
      "suites": [
        {
          "uuid": "eb21a5d6-e0ef-42d4-97eb-6b5e6e8c75aa",
          "title": "telnyx.com",
          "fullFile": "",
          "file": "",
          "beforeHooks": [],
          "afterHooks": [],
          "tests": [
            {
              "title": "A10 - Checking the ability to go to the sign up page from the login page",
              "fullTitle": "telnyx.com A10 - Checking the ability to go to the sign up page from the login page",
              "timedOut": null,
              "duration": 615,
              "state": "failed",
              "speed": null,
              "pass": false,
              "fail": true,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {
                "message": "TypeError: _login.default.acceptCookies is not a function",
                "estack": "TypeError: _login.default.acceptCookies is not a function\n    at Context.eval (cypress/e2e/tests/goToSignUp.js:7:12)\n    at Registry.runStepDefininition (node_modules/@badeball/cypress-cucumber-preprocessor/lib/registry.js:119:0)\n    at Context.eval (node_modules/@badeball/cypress-cucumber-preprocessor/lib/create-tests.js:291:0)",
                "diff": null
              },
              "uuid": "e5640a2d-1d69-4396-ba2a-99b19b37f039",
              "parentUUID": "eb21a5d6-e0ef-42d4-97eb-6b5e6e8c75aa",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "A14 - Checking the ability to go to the sign up page from footer",
              "fullTitle": "telnyx.com A14 - Checking the ability to go to the sign up page from footer",
              "timedOut": null,
              "duration": 881,
              "state": "failed",
              "speed": null,
              "pass": false,
              "fail": true,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {
                "message": "TypeError: _login.default.acceptCookies is not a function",
                "estack": "TypeError: _login.default.acceptCookies is not a function\n    at Context.eval (cypress/e2e/tests/goToSignUp.js:7:12)\n    at Registry.runStepDefininition (node_modules/@badeball/cypress-cucumber-preprocessor/lib/registry.js:119:0)\n    at Context.eval (node_modules/@badeball/cypress-cucumber-preprocessor/lib/create-tests.js:291:0)",
                "diff": null
              },
              "uuid": "6092eb5f-a452-463c-a036-e5619f3c7c9c",
              "parentUUID": "eb21a5d6-e0ef-42d4-97eb-6b5e6e8c75aa",
              "isHook": false,
              "skipped": false
            }
          ],
          "suites": [],
          "passes": [],
          "failures": [
            "e5640a2d-1d69-4396-ba2a-99b19b37f039",
            "6092eb5f-a452-463c-a036-e5619f3c7c9c"
          ],
          "pending": [],
          "skipped": [],
          "duration": 1496,
          "root": false,
          "rootEmpty": false,
          "_timeout": 2000
        }
      ],
      "passes": [],
      "failures": [],
      "pending": [],
      "skipped": [],
      "duration": 0,
      "root": true,
      "rootEmpty": true,
      "_timeout": 2000
    },
    {
      "uuid": "07e5496a-6062-43c7-9d6a-43c0d9385318",
      "title": "",
      "fullFile": "cypress/e2e/tests/products.feature",
      "file": "cypress/e2e/tests/products.feature",
      "beforeHooks": [],
      "afterHooks": [],
      "tests": [],
      "suites": [
        {
          "uuid": "40e773e8-ce49-4659-a129-50a6aeeaf2da",
          "title": "telnyx.com",
          "fullFile": "",
          "file": "",
          "beforeHooks": [],
          "afterHooks": [],
          "tests": [
            {
              "title": "A1 - Checking that it is possible to see all products by menu",
              "fullTitle": "telnyx.com A1 - Checking that it is possible to see all products by menu",
              "timedOut": null,
              "duration": 9272,
              "state": "passed",
              "speed": "medium",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {},
              "uuid": "5a5c2599-65b2-4c24-89c5-20eb2f7ec59a",
              "parentUUID": "40e773e8-ce49-4659-a129-50a6aeeaf2da",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "A2 - Checking that it is possible to see all products by the main page",
              "fullTitle": "telnyx.com A2 - Checking that it is possible to see all products by the main page",
              "timedOut": null,
              "duration": 10977,
              "state": "passed",
              "speed": "slow",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {},
              "uuid": "f94b9055-01e5-4f04-8266-e9a073924a84",
              "parentUUID": "40e773e8-ce49-4659-a129-50a6aeeaf2da",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "A3 - Checking that it is possible to see all products by the footer",
              "fullTitle": "telnyx.com A3 - Checking that it is possible to see all products by the footer",
              "timedOut": null,
              "duration": 4960,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {},
              "uuid": "1a39e572-12c5-459e-bf64-dec4004b0d20",
              "parentUUID": "40e773e8-ce49-4659-a129-50a6aeeaf2da",
              "isHook": false,
              "skipped": false
            }
          ],
          "suites": [],
          "passes": [
            "5a5c2599-65b2-4c24-89c5-20eb2f7ec59a",
            "f94b9055-01e5-4f04-8266-e9a073924a84",
            "1a39e572-12c5-459e-bf64-dec4004b0d20"
          ],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 25209,
          "root": false,
          "rootEmpty": false,
          "_timeout": 2000
        }
      ],
      "passes": [],
      "failures": [],
      "pending": [],
      "skipped": [],
      "duration": 0,
      "root": true,
      "rootEmpty": true,
      "_timeout": 2000
    },
    {
      "uuid": "ab33e8cf-2d1e-43dd-9b2b-ac394d6a14cb",
      "title": "",
      "fullFile": "cypress/e2e/tests/products.feature",
      "file": "cypress/e2e/tests/products.feature",
      "beforeHooks": [],
      "afterHooks": [],
      "tests": [],
      "suites": [
        {
          "uuid": "e47d7ed6-0bbc-44ee-afae-fdb1adf145c0",
          "title": "telnyx.com",
          "fullFile": "",
          "file": "",
          "beforeHooks": [],
          "afterHooks": [],
          "tests": [
            {
              "title": "A1 - Checking that it is possible to see all products by menu",
              "fullTitle": "telnyx.com A1 - Checking that it is possible to see all products by menu",
              "timedOut": null,
              "duration": 5866,
              "state": "failed",
              "speed": null,
              "pass": false,
              "fail": true,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {
                "message": "Error: Multiple matching step definitions for: I click in the menu button\n I click in the menu button\n I click in the menu button",
                "estack": "Error: Multiple matching step definitions for: I click in the menu button\n I click in the menu button\n I click in the menu button\n    at Registry.resolveStepDefintion (node_modules/@badeball/cypress-cucumber-preprocessor/lib/registry.js:90:0)\n    at Registry.runStepDefininition (node_modules/@badeball/cypress-cucumber-preprocessor/lib/registry.js:111:0)\n    at Context.eval (node_modules/@badeball/cypress-cucumber-preprocessor/lib/create-tests.js:291:0)",
                "diff": null
              },
              "uuid": "1ba3a9af-856d-414f-aa4a-f52381357936",
              "parentUUID": "e47d7ed6-0bbc-44ee-afae-fdb1adf145c0",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "A2 - Checking that it is possible to see all products by the main page",
              "fullTitle": "telnyx.com A2 - Checking that it is possible to see all products by the main page",
              "timedOut": null,
              "duration": 6420,
              "state": "failed",
              "speed": null,
              "pass": false,
              "fail": true,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {
                "message": "Error: \nStep implementation missing for \"I should be switched to the products page\".\n\nWe tried searching for files containing step definitions using the following search pattern templates:\n\n  - cypress/e2e/tests/[filepath]/**/*.{js,mjs,ts,tsx}\n  - cypress/e2e/tests/[filepath].{js,mjs,ts,tsx}\n  - cypress/support/step_definitions/**/*.{js,mjs,ts,tsx}\n\nThese templates resolved to the following search patterns:\n\n  - cypress/e2e/tests/products/**/*.{js,mjs,ts,tsx}\n  - cypress/e2e/tests/products.{js,mjs,ts,tsx}\n  - cypress/support/step_definitions/**/*.{js,mjs,ts,tsx}\n\nThese patterns matched the following files:\n\n  - cypress/e2e/tests/products.js\n\nHowever, none of these files contained a step definition matching \"I should be switched to the products page\".\n\nYou can implement it using the suggestion(s) below.\n\n  Given(\"I should be switched to the products page\", function () {\n    return \"pending\";\n  });\n  ",
                "estack": "Error: \nStep implementation missing for \"I should be switched to the products page\".\n\nWe tried searching for files containing step definitions using the following search pattern templates:\n\n  - cypress/e2e/tests/[filepath]/**/*.{js,mjs,ts,tsx}\n  - cypress/e2e/tests/[filepath].{js,mjs,ts,tsx}\n  - cypress/support/step_definitions/**/*.{js,mjs,ts,tsx}\n\nThese templates resolved to the following search patterns:\n\n  - cypress/e2e/tests/products/**/*.{js,mjs,ts,tsx}\n  - cypress/e2e/tests/products.{js,mjs,ts,tsx}\n  - cypress/support/step_definitions/**/*.{js,mjs,ts,tsx}\n\nThese patterns matched the following files:\n\n  - cypress/e2e/tests/products.js\n\nHowever, none of these files contained a step definition matching \"I should be switched to the products page\".\n\nYou can implement it using the suggestion(s) below.\n\n  Given(\"I should be switched to the products page\", function () {\n    return \"pending\";\n  });\n  \n    at Context.eval (node_modules/@badeball/cypress-cucumber-preprocessor/lib/create-tests.js:300:0)",
                "diff": null
              },
              "uuid": "27f5a387-200f-4305-99e6-3079adf21702",
              "parentUUID": "e47d7ed6-0bbc-44ee-afae-fdb1adf145c0",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "A3 - Checking that it is possible to see all products by the footer",
              "fullTitle": "telnyx.com A3 - Checking that it is possible to see all products by the footer",
              "timedOut": null,
              "duration": 8466,
              "state": "failed",
              "speed": null,
              "pass": false,
              "fail": true,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {
                "message": "Error: \nStep implementation missing for \"I click All products on footer\".\n\nWe tried searching for files containing step definitions using the following search pattern templates:\n\n  - cypress/e2e/tests/[filepath]/**/*.{js,mjs,ts,tsx}\n  - cypress/e2e/tests/[filepath].{js,mjs,ts,tsx}\n  - cypress/support/step_definitions/**/*.{js,mjs,ts,tsx}\n\nThese templates resolved to the following search patterns:\n\n  - cypress/e2e/tests/products/**/*.{js,mjs,ts,tsx}\n  - cypress/e2e/tests/products.{js,mjs,ts,tsx}\n  - cypress/support/step_definitions/**/*.{js,mjs,ts,tsx}\n\nThese patterns matched the following files:\n\n  - cypress/e2e/tests/products.js\n\nHowever, none of these files contained a step definition matching \"I click All products on footer\".\n\nYou can implement it using the suggestion(s) below.\n\n  Given(\"I click All products on footer\", function () {\n    return \"pending\";\n  });\n  ",
                "estack": "Error: \nStep implementation missing for \"I click All products on footer\".\n\nWe tried searching for files containing step definitions using the following search pattern templates:\n\n  - cypress/e2e/tests/[filepath]/**/*.{js,mjs,ts,tsx}\n  - cypress/e2e/tests/[filepath].{js,mjs,ts,tsx}\n  - cypress/support/step_definitions/**/*.{js,mjs,ts,tsx}\n\nThese templates resolved to the following search patterns:\n\n  - cypress/e2e/tests/products/**/*.{js,mjs,ts,tsx}\n  - cypress/e2e/tests/products.{js,mjs,ts,tsx}\n  - cypress/support/step_definitions/**/*.{js,mjs,ts,tsx}\n\nThese patterns matched the following files:\n\n  - cypress/e2e/tests/products.js\n\nHowever, none of these files contained a step definition matching \"I click All products on footer\".\n\nYou can implement it using the suggestion(s) below.\n\n  Given(\"I click All products on footer\", function () {\n    return \"pending\";\n  });\n  \n    at Context.eval (node_modules/@badeball/cypress-cucumber-preprocessor/lib/create-tests.js:300:0)",
                "diff": null
              },
              "uuid": "ec0a8fd5-0355-4fd0-b688-a52febc2a8ba",
              "parentUUID": "e47d7ed6-0bbc-44ee-afae-fdb1adf145c0",
              "isHook": false,
              "skipped": false
            }
          ],
          "suites": [],
          "passes": [],
          "failures": [
            "1ba3a9af-856d-414f-aa4a-f52381357936",
            "27f5a387-200f-4305-99e6-3079adf21702",
            "ec0a8fd5-0355-4fd0-b688-a52febc2a8ba"
          ],
          "pending": [],
          "skipped": [],
          "duration": 20752,
          "root": false,
          "rootEmpty": false,
          "_timeout": 2000
        }
      ],
      "passes": [],
      "failures": [],
      "pending": [],
      "skipped": [],
      "duration": 0,
      "root": true,
      "rootEmpty": true,
      "_timeout": 2000
    },
    {
      "uuid": "3f633424-d6e1-4dd0-ae79-b241cf0f3502",
      "title": "",
      "fullFile": "cypress/e2e/tests/switchSave.feature",
      "file": "cypress/e2e/tests/switchSave.feature",
      "beforeHooks": [],
      "afterHooks": [],
      "tests": [],
      "suites": [
        {
          "uuid": "9ee08c10-d76a-44a0-bdfa-6956e8b3c7b6",
          "title": "telnyx.com",
          "fullFile": "",
          "file": "",
          "beforeHooks": [],
          "afterHooks": [],
          "tests": [
            {
              "title": "A5 - Checking the ability to change data by slider",
              "fullTitle": "telnyx.com A5 - Checking the ability to change data by slider",
              "timedOut": null,
              "duration": 20446,
              "state": "passed",
              "speed": "slow",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {},
              "uuid": "0e4e878b-ae89-4253-b01a-3f8a72b395e1",
              "parentUUID": "9ee08c10-d76a-44a0-bdfa-6956e8b3c7b6",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "A6 - Checking the ability to change data and look at the current price",
              "fullTitle": "telnyx.com A6 - Checking the ability to change data and look at the current price",
              "timedOut": null,
              "duration": 16403,
              "state": "passed",
              "speed": "slow",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {},
              "uuid": "71241225-9f90-4e41-bca1-8f8276697000",
              "parentUUID": "9ee08c10-d76a-44a0-bdfa-6956e8b3c7b6",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "A7 - Checking the ability to see how much money will be save up",
              "fullTitle": "telnyx.com A7 - Checking the ability to see how much money will be save up",
              "timedOut": null,
              "duration": 19372,
              "state": "passed",
              "speed": "slow",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {},
              "uuid": "55864fd8-a518-46c5-a400-daf6b6c050a4",
              "parentUUID": "9ee08c10-d76a-44a0-bdfa-6956e8b3c7b6",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "A13 - Checking the ability to go to the sign up page from 'Switch + Save with Tenlyx' section",
              "fullTitle": "telnyx.com A13 - Checking the ability to go to the sign up page from 'Switch + Save with Tenlyx' section",
              "timedOut": null,
              "duration": 24318,
              "state": "passed",
              "speed": "slow",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {},
              "uuid": "00f8e087-b62b-4b55-b9f0-4bcb1ba400b1",
              "parentUUID": "9ee08c10-d76a-44a0-bdfa-6956e8b3c7b6",
              "isHook": false,
              "skipped": false
            }
          ],
          "suites": [],
          "passes": [
            "0e4e878b-ae89-4253-b01a-3f8a72b395e1",
            "71241225-9f90-4e41-bca1-8f8276697000",
            "55864fd8-a518-46c5-a400-daf6b6c050a4",
            "00f8e087-b62b-4b55-b9f0-4bcb1ba400b1"
          ],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 80539,
          "root": false,
          "rootEmpty": false,
          "_timeout": 2000
        }
      ],
      "passes": [],
      "failures": [],
      "pending": [],
      "skipped": [],
      "duration": 0,
      "root": true,
      "rootEmpty": true,
      "_timeout": 2000
    },
    {
      "uuid": "ec1a4ccd-7998-4e49-9a9a-a1c120057994",
      "title": "",
      "fullFile": "cypress/e2e/tests/story.feature",
      "file": "cypress/e2e/tests/story.feature",
      "beforeHooks": [],
      "afterHooks": [],
      "tests": [],
      "suites": [
        {
          "uuid": "119bc3c8-47cd-4f82-8432-eb4fb39d3c40",
          "title": "telnyx.com",
          "fullFile": "",
          "file": "",
          "beforeHooks": [],
          "afterHooks": [],
          "tests": [
            {
              "title": "A4 - Checking the ability to read customers stories",
              "fullTitle": "telnyx.com A4 - Checking the ability to read customers stories",
              "timedOut": null,
              "duration": 16529,
              "state": "failed",
              "speed": null,
              "pass": false,
              "fail": true,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {
                "message": "AssertionError: Timed out retrying after 10000ms: expected 'https://telnyx.com/customer-stories/lightspeed' to include '/custumer-stories'",
                "estack": "AssertionError: Timed out retrying after 10000ms: expected 'https://telnyx.com/customer-stories/lightspeed' to include '/custumer-stories'\n    at Context.eval (cypress/e2e/tests/story.js:20:13)\n    at Registry.runStepDefininition (node_modules/@badeball/cypress-cucumber-preprocessor/lib/registry.js:119:0)\n    at Context.eval (node_modules/@badeball/cypress-cucumber-preprocessor/lib/create-tests.js:291:0)",
                "diff": null
              },
              "uuid": "abe08eb2-46dc-435d-9109-c585e3a0bca2",
              "parentUUID": "119bc3c8-47cd-4f82-8432-eb4fb39d3c40",
              "isHook": false,
              "skipped": false
            }
          ],
          "suites": [],
          "passes": [],
          "failures": [
            "abe08eb2-46dc-435d-9109-c585e3a0bca2"
          ],
          "pending": [],
          "skipped": [],
          "duration": 16529,
          "root": false,
          "rootEmpty": false,
          "_timeout": 2000
        }
      ],
      "passes": [],
      "failures": [],
      "pending": [],
      "skipped": [],
      "duration": 0,
      "root": true,
      "rootEmpty": true,
      "_timeout": 2000
    },
    {
      "uuid": "b710411f-0e52-4dfe-bb27-66c91da96147",
      "title": "",
      "fullFile": "cypress/e2e/tests/twitter.feature",
      "file": "cypress/e2e/tests/twitter.feature",
      "beforeHooks": [],
      "afterHooks": [],
      "tests": [],
      "suites": [
        {
          "uuid": "18d6b632-1677-454a-99b9-39969056d4b4",
          "title": "telnyx.com",
          "fullFile": "",
          "file": "",
          "beforeHooks": [],
          "afterHooks": [],
          "tests": [
            {
              "title": "A15 -  Check that the site is linked with Twitter",
              "fullTitle": "telnyx.com A15 -  Check that the site is linked with Twitter",
              "timedOut": null,
              "duration": 8961,
              "state": "passed",
              "speed": "medium",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {},
              "uuid": "d8bcd8a5-24b0-416d-8717-8770c4a366f0",
              "parentUUID": "18d6b632-1677-454a-99b9-39969056d4b4",
              "isHook": false,
              "skipped": false
            }
          ],
          "suites": [],
          "passes": [
            "d8bcd8a5-24b0-416d-8717-8770c4a366f0"
          ],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 8961,
          "root": false,
          "rootEmpty": false,
          "_timeout": 2000
        }
      ],
      "passes": [],
      "failures": [],
      "pending": [],
      "skipped": [],
      "duration": 0,
      "root": true,
      "rootEmpty": true,
      "_timeout": 2000
    },
    {
      "uuid": "c14fed91-5de2-45aa-9c71-ab1883d500ad",
      "title": "",
      "fullFile": "cypress/e2e/tests/switchSave.feature",
      "file": "cypress/e2e/tests/switchSave.feature",
      "beforeHooks": [],
      "afterHooks": [],
      "tests": [],
      "suites": [
        {
          "uuid": "d0050e64-2e8a-4ed5-afe2-82f959449359",
          "title": "telnyx.com",
          "fullFile": "",
          "file": "",
          "beforeHooks": [],
          "afterHooks": [],
          "tests": [
            {
              "title": "A5 - Checking the ability to change data by slider",
              "fullTitle": "telnyx.com A5 - Checking the ability to change data by slider",
              "timedOut": null,
              "duration": 17057,
              "state": "passed",
              "speed": "slow",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {},
              "uuid": "453cf598-a32d-4aa7-9eee-a7f53e8e15d2",
              "parentUUID": "d0050e64-2e8a-4ed5-afe2-82f959449359",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "A6 - Checking the ability to change data and look at the current price",
              "fullTitle": "telnyx.com A6 - Checking the ability to change data and look at the current price",
              "timedOut": null,
              "duration": 11109,
              "state": "failed",
              "speed": null,
              "pass": false,
              "fail": true,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {
                "message": "TypeError: _main.default.dragSendMessageSlider is not a function",
                "estack": "TypeError: _main.default.dragSendMessageSlider is not a function\n    at Context.eval (cypress/e2e/tests/switchSave.js:42:13)\n    at Registry.runStepDefininition (node_modules/@badeball/cypress-cucumber-preprocessor/lib/registry.js:119:0)\n    at Context.eval (node_modules/@badeball/cypress-cucumber-preprocessor/lib/create-tests.js:291:0)",
                "diff": null
              },
              "uuid": "1ddce33d-41f0-4c7a-ab65-c266711b0cf3",
              "parentUUID": "d0050e64-2e8a-4ed5-afe2-82f959449359",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "A7 - Checking the ability to see how much money will be save up",
              "fullTitle": "telnyx.com A7 - Checking the ability to see how much money will be save up",
              "timedOut": null,
              "duration": 8973,
              "state": "failed",
              "speed": null,
              "pass": false,
              "fail": true,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {
                "message": "TypeError: _main.default.dragMakeCallsSlider is not a function",
                "estack": "TypeError: _main.default.dragMakeCallsSlider is not a function\n    at Context.eval (cypress/e2e/tests/switchSave.js:49:11)\n    at Registry.runStepDefininition (node_modules/@badeball/cypress-cucumber-preprocessor/lib/registry.js:119:0)\n    at Context.eval (node_modules/@badeball/cypress-cucumber-preprocessor/lib/create-tests.js:291:0)",
                "diff": null
              },
              "uuid": "259d9507-744e-45a5-8fe0-50fe3410e324",
              "parentUUID": "d0050e64-2e8a-4ed5-afe2-82f959449359",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "A13 - Checking the ability to go to the sign up page from 'Switch + Save with Tenlyx' section",
              "fullTitle": "telnyx.com A13 - Checking the ability to go to the sign up page from 'Switch + Save with Tenlyx' section",
              "timedOut": null,
              "duration": 9208,
              "state": "passed",
              "speed": "medium",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {},
              "uuid": "05872ce0-afd5-4553-8696-2bdb77882f22",
              "parentUUID": "d0050e64-2e8a-4ed5-afe2-82f959449359",
              "isHook": false,
              "skipped": false
            }
          ],
          "suites": [],
          "passes": [
            "453cf598-a32d-4aa7-9eee-a7f53e8e15d2",
            "05872ce0-afd5-4553-8696-2bdb77882f22"
          ],
          "failures": [
            "1ddce33d-41f0-4c7a-ab65-c266711b0cf3",
            "259d9507-744e-45a5-8fe0-50fe3410e324"
          ],
          "pending": [],
          "skipped": [],
          "duration": 46347,
          "root": false,
          "rootEmpty": false,
          "_timeout": 2000
        }
      ],
      "passes": [],
      "failures": [],
      "pending": [],
      "skipped": [],
      "duration": 0,
      "root": true,
      "rootEmpty": true,
      "_timeout": 2000
    },
    {
      "uuid": "208533d2-9945-4bda-b2d5-30c4cd37e573",
      "title": "",
      "fullFile": "cypress/e2e/tests/API.feature",
      "file": "cypress/e2e/tests/API.feature",
      "beforeHooks": [],
      "afterHooks": [],
      "tests": [],
      "suites": [
        {
          "uuid": "66fbd8c9-4052-491c-9dd8-6e430fbbb25f",
          "title": "telnyx.com",
          "fullFile": "",
          "file": "",
          "beforeHooks": [],
          "afterHooks": [],
          "tests": [
            {
              "title": "A9 - Checking the ability to learn more about API documentation",
              "fullTitle": "telnyx.com A9 - Checking the ability to learn more about API documentation",
              "timedOut": null,
              "duration": 10578,
              "state": "passed",
              "speed": "slow",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {},
              "uuid": "035a9ecc-eb6f-4ffc-9a9b-c190b6df532d",
              "parentUUID": "66fbd8c9-4052-491c-9dd8-6e430fbbb25f",
              "isHook": false,
              "skipped": false
            }
          ],
          "suites": [],
          "passes": [
            "035a9ecc-eb6f-4ffc-9a9b-c190b6df532d"
          ],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 10578,
          "root": false,
          "rootEmpty": false,
          "_timeout": 2000
        }
      ],
      "passes": [],
      "failures": [],
      "pending": [],
      "skipped": [],
      "duration": 0,
      "root": true,
      "rootEmpty": true,
      "_timeout": 2000
    },
    {
      "uuid": "21421fd3-d4ea-46e5-ae3f-d6e0655a9308",
      "title": "",
      "fullFile": "cypress/e2e/tests/twitter.feature",
      "file": "cypress/e2e/tests/twitter.feature",
      "beforeHooks": [],
      "afterHooks": [],
      "tests": [],
      "suites": [
        {
          "uuid": "5540928f-6df8-4a29-a208-09c50eb68700",
          "title": "telnyx.com",
          "fullFile": "",
          "file": "",
          "beforeHooks": [],
          "afterHooks": [],
          "tests": [
            {
              "title": "A15 -  Check that the site is linked with Twitter",
              "fullTitle": "telnyx.com A15 -  Check that the site is linked with Twitter",
              "timedOut": null,
              "duration": 8654,
              "state": "passed",
              "speed": "medium",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {},
              "uuid": "2c0fff35-3f0a-44c8-b4f3-f6b0128a176d",
              "parentUUID": "5540928f-6df8-4a29-a208-09c50eb68700",
              "isHook": false,
              "skipped": false
            }
          ],
          "suites": [],
          "passes": [
            "2c0fff35-3f0a-44c8-b4f3-f6b0128a176d"
          ],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 8654,
          "root": false,
          "rootEmpty": false,
          "_timeout": 2000
        }
      ],
      "passes": [],
      "failures": [],
      "pending": [],
      "skipped": [],
      "duration": 0,
      "root": true,
      "rootEmpty": true,
      "_timeout": 2000
    },
    {
      "uuid": "ca6374e6-a3d9-4528-8603-365ec01a2965",
      "title": "",
      "fullFile": "cypress/e2e/tests/comments.feature",
      "file": "cypress/e2e/tests/comments.feature",
      "beforeHooks": [],
      "afterHooks": [],
      "tests": [],
      "suites": [
        {
          "uuid": "f879606b-a01d-422f-83fe-4a77e93b75e1",
          "title": "telnyx.com",
          "fullFile": "",
          "file": "",
          "beforeHooks": [],
          "afterHooks": [],
          "tests": [
            {
              "title": "A8 - Checking the ability to switch customers' comments",
              "fullTitle": "telnyx.com A8 - Checking the ability to switch customers' comments",
              "timedOut": null,
              "duration": 4712,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {},
              "uuid": "db326813-a3fd-4c59-bac6-d73a5386019e",
              "parentUUID": "f879606b-a01d-422f-83fe-4a77e93b75e1",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "A12 - Checking the ability to switch customers' comments",
              "fullTitle": "telnyx.com A12 - Checking the ability to switch customers' comments",
              "timedOut": null,
              "duration": 6621,
              "state": "failed",
              "speed": null,
              "pass": false,
              "fail": true,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {
                "message": "Error: \nStep implementation missing for \"customers' comments should be  switched automatically\".\n\nWe tried searching for files containing step definitions using the following search pattern templates:\n\n  - cypress/e2e/tests/[filepath]/**/*.{js,mjs,ts,tsx}\n  - cypress/e2e/tests/[filepath].{js,mjs,ts,tsx}\n  - cypress/support/step_definitions/**/*.{js,mjs,ts,tsx}\n\nThese templates resolved to the following search patterns:\n\n  - cypress/e2e/tests/comments/**/*.{js,mjs,ts,tsx}\n  - cypress/e2e/tests/comments.{js,mjs,ts,tsx}\n  - cypress/support/step_definitions/**/*.{js,mjs,ts,tsx}\n\nThese patterns matched the following files:\n\n  - cypress/e2e/tests/comments.js\n\nHowever, none of these files contained a step definition matching \"customers' comments should be  switched automatically\".\n\nYou can implement it using the suggestion(s) below.\n\n  Given(\"customers' comments should be  switched automatically\", function () {\n    return \"pending\";\n  });\n  ",
                "estack": "Error: \nStep implementation missing for \"customers' comments should be  switched automatically\".\n\nWe tried searching for files containing step definitions using the following search pattern templates:\n\n  - cypress/e2e/tests/[filepath]/**/*.{js,mjs,ts,tsx}\n  - cypress/e2e/tests/[filepath].{js,mjs,ts,tsx}\n  - cypress/support/step_definitions/**/*.{js,mjs,ts,tsx}\n\nThese templates resolved to the following search patterns:\n\n  - cypress/e2e/tests/comments/**/*.{js,mjs,ts,tsx}\n  - cypress/e2e/tests/comments.{js,mjs,ts,tsx}\n  - cypress/support/step_definitions/**/*.{js,mjs,ts,tsx}\n\nThese patterns matched the following files:\n\n  - cypress/e2e/tests/comments.js\n\nHowever, none of these files contained a step definition matching \"customers' comments should be  switched automatically\".\n\nYou can implement it using the suggestion(s) below.\n\n  Given(\"customers' comments should be  switched automatically\", function () {\n    return \"pending\";\n  });\n  \n    at Context.eval (node_modules/@badeball/cypress-cucumber-preprocessor/lib/create-tests.js:300:0)",
                "diff": null
              },
              "uuid": "ea4afa01-0118-47d6-a747-6193d6eda0f8",
              "parentUUID": "f879606b-a01d-422f-83fe-4a77e93b75e1",
              "isHook": false,
              "skipped": false
            }
          ],
          "suites": [],
          "passes": [
            "db326813-a3fd-4c59-bac6-d73a5386019e"
          ],
          "failures": [
            "ea4afa01-0118-47d6-a747-6193d6eda0f8"
          ],
          "pending": [],
          "skipped": [],
          "duration": 11333,
          "root": false,
          "rootEmpty": false,
          "_timeout": 2000
        }
      ],
      "passes": [],
      "failures": [],
      "pending": [],
      "skipped": [],
      "duration": 0,
      "root": true,
      "rootEmpty": true,
      "_timeout": 2000
    },
    {
      "uuid": "d9ac26df-2bbf-4797-ae8f-e671539cffe2",
      "title": "",
      "fullFile": "cypress/e2e/tests/API.feature",
      "file": "cypress/e2e/tests/API.feature",
      "beforeHooks": [],
      "afterHooks": [],
      "tests": [],
      "suites": [
        {
          "uuid": "8aa3d699-c9dd-4688-835c-8dc466ba0256",
          "title": "telnyx.com",
          "fullFile": "",
          "file": "",
          "beforeHooks": [],
          "afterHooks": [],
          "tests": [
            {
              "title": "A9 - Checking the ability to learn more about API documentation",
              "fullTitle": "telnyx.com A9 - Checking the ability to learn more about API documentation",
              "timedOut": null,
              "duration": 17124,
              "state": "passed",
              "speed": "slow",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {},
              "uuid": "0a3ccfe1-997f-4d5e-9c15-c35fd677975d",
              "parentUUID": "8aa3d699-c9dd-4688-835c-8dc466ba0256",
              "isHook": false,
              "skipped": false
            }
          ],
          "suites": [],
          "passes": [
            "0a3ccfe1-997f-4d5e-9c15-c35fd677975d"
          ],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 17124,
          "root": false,
          "rootEmpty": false,
          "_timeout": 2000
        }
      ],
      "passes": [],
      "failures": [],
      "pending": [],
      "skipped": [],
      "duration": 0,
      "root": true,
      "rootEmpty": true,
      "_timeout": 2000
    },
    {
      "uuid": "aa6df5c2-1d8d-466e-b95d-74fa885afea8",
      "title": "",
      "fullFile": "cypress/e2e/tests/customerStory.feature",
      "file": "cypress/e2e/tests/customerStory.feature",
      "beforeHooks": [],
      "afterHooks": [],
      "tests": [],
      "suites": [
        {
          "uuid": "a8c0d79e-1c87-4f0c-ac43-ca3352154c96",
          "title": "telnyx.com",
          "fullFile": "",
          "file": "",
          "beforeHooks": [],
          "afterHooks": [],
          "tests": [
            {
              "title": "A4 - Checking the ability to read customers stories",
              "fullTitle": "telnyx.com A4 - Checking the ability to read customers stories",
              "timedOut": null,
              "duration": 5477,
              "state": "passed",
              "speed": "medium",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {},
              "uuid": "17f44f24-ba69-4286-9e78-6eac1d867c4d",
              "parentUUID": "a8c0d79e-1c87-4f0c-ac43-ca3352154c96",
              "isHook": false,
              "skipped": false
            }
          ],
          "suites": [],
          "passes": [
            "17f44f24-ba69-4286-9e78-6eac1d867c4d"
          ],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 5477,
          "root": false,
          "rootEmpty": false,
          "_timeout": 2000
        }
      ],
      "passes": [],
      "failures": [],
      "pending": [],
      "skipped": [],
      "duration": 0,
      "root": true,
      "rootEmpty": true,
      "_timeout": 2000
    },
    {
      "uuid": "e8843d5c-14c9-4ade-a2a9-985407fa11d8",
      "title": "",
      "fullFile": "cypress/e2e/tests/comments.feature",
      "file": "cypress/e2e/tests/comments.feature",
      "beforeHooks": [],
      "afterHooks": [],
      "tests": [],
      "suites": [
        {
          "uuid": "96db01a2-4760-4b14-9c0d-0e8a8a24b3b5",
          "title": "telnyx.com",
          "fullFile": "",
          "file": "",
          "beforeHooks": [],
          "afterHooks": [],
          "tests": [
            {
              "title": "A8 - Checking the ability to switch customers' comments",
              "fullTitle": "telnyx.com A8 - Checking the ability to switch customers' comments",
              "timedOut": null,
              "duration": 5819,
              "state": "passed",
              "speed": "medium",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {},
              "uuid": "22e05a04-d47d-4595-8652-282115c28b02",
              "parentUUID": "96db01a2-4760-4b14-9c0d-0e8a8a24b3b5",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "A12 - Checking the ability to switch customers' comments",
              "fullTitle": "telnyx.com A12 - Checking the ability to switch customers' comments",
              "timedOut": null,
              "duration": 11912,
              "state": "passed",
              "speed": "slow",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {},
              "uuid": "dba8021f-c787-4c16-898e-5e556487d19e",
              "parentUUID": "96db01a2-4760-4b14-9c0d-0e8a8a24b3b5",
              "isHook": false,
              "skipped": false
            }
          ],
          "suites": [],
          "passes": [
            "22e05a04-d47d-4595-8652-282115c28b02",
            "dba8021f-c787-4c16-898e-5e556487d19e"
          ],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 17731,
          "root": false,
          "rootEmpty": false,
          "_timeout": 2000
        }
      ],
      "passes": [],
      "failures": [],
      "pending": [],
      "skipped": [],
      "duration": 0,
      "root": true,
      "rootEmpty": true,
      "_timeout": 2000
    },
    {
      "uuid": "0fc2c760-a12d-463d-a2e7-0358c76bdea5",
      "title": "",
      "fullFile": "cypress/e2e/tests/goToLogin.feature",
      "file": "cypress/e2e/tests/goToLogin.feature",
      "beforeHooks": [],
      "afterHooks": [],
      "tests": [],
      "suites": [
        {
          "uuid": "7001242c-5636-49b5-b08e-b02417d5623a",
          "title": "telnyx.com",
          "fullFile": "",
          "file": "",
          "beforeHooks": [],
          "afterHooks": [],
          "tests": [
            {
              "title": "A11 - Checking the ability to go to the login page from the sign up page",
              "fullTitle": "telnyx.com A11 - Checking the ability to go to the login page from the sign up page",
              "timedOut": null,
              "duration": 26146,
              "state": "passed",
              "speed": "slow",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {},
              "uuid": "2feed95b-4816-49f0-be44-27a86f5ff98a",
              "parentUUID": "7001242c-5636-49b5-b08e-b02417d5623a",
              "isHook": false,
              "skipped": false
            }
          ],
          "suites": [],
          "passes": [
            "2feed95b-4816-49f0-be44-27a86f5ff98a"
          ],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 26146,
          "root": false,
          "rootEmpty": false,
          "_timeout": 2000
        }
      ],
      "passes": [],
      "failures": [],
      "pending": [],
      "skipped": [],
      "duration": 0,
      "root": true,
      "rootEmpty": true,
      "_timeout": 2000
    },
    {
      "uuid": "92918103-2530-4353-a8c2-b440f2bbecea",
      "title": "",
      "fullFile": "cypress/e2e/tests/API.feature",
      "file": "cypress/e2e/tests/API.feature",
      "beforeHooks": [],
      "afterHooks": [],
      "tests": [],
      "suites": [
        {
          "uuid": "6761dd44-c241-4979-b1ae-6dcd7b012a26",
          "title": "telnyx.com",
          "fullFile": "",
          "file": "",
          "beforeHooks": [],
          "afterHooks": [],
          "tests": [
            {
              "title": "A9 - Checking the ability to learn more about API documentation",
              "fullTitle": "telnyx.com A9 - Checking the ability to learn more about API documentation",
              "timedOut": null,
              "duration": 10254,
              "state": "passed",
              "speed": "slow",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {},
              "uuid": "f21935da-80da-4fcc-9ac7-f61213baec55",
              "parentUUID": "6761dd44-c241-4979-b1ae-6dcd7b012a26",
              "isHook": false,
              "skipped": false
            }
          ],
          "suites": [],
          "passes": [
            "f21935da-80da-4fcc-9ac7-f61213baec55"
          ],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 10254,
          "root": false,
          "rootEmpty": false,
          "_timeout": 2000
        }
      ],
      "passes": [],
      "failures": [],
      "pending": [],
      "skipped": [],
      "duration": 0,
      "root": true,
      "rootEmpty": true,
      "_timeout": 2000
    },
    {
      "uuid": "bfc9c8ca-7e32-44ff-8bc2-d8c28f5e1973",
      "title": "",
      "fullFile": "cypress/e2e/tests/API.feature",
      "file": "cypress/e2e/tests/API.feature",
      "beforeHooks": [],
      "afterHooks": [],
      "tests": [],
      "suites": [
        {
          "uuid": "25580779-6fe4-4871-993f-d6ade2cb7c3d",
          "title": "telnyx.com",
          "fullFile": "",
          "file": "",
          "beforeHooks": [],
          "afterHooks": [],
          "tests": [
            {
              "title": "A9 - Checking the ability to learn more about API documentation",
              "fullTitle": "telnyx.com A9 - Checking the ability to learn more about API documentation",
              "timedOut": null,
              "duration": 10424,
              "state": "passed",
              "speed": "slow",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {},
              "uuid": "5547c6fb-53e9-4c24-90e9-a480c6078cdc",
              "parentUUID": "25580779-6fe4-4871-993f-d6ade2cb7c3d",
              "isHook": false,
              "skipped": false
            }
          ],
          "suites": [],
          "passes": [
            "5547c6fb-53e9-4c24-90e9-a480c6078cdc"
          ],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 10424,
          "root": false,
          "rootEmpty": false,
          "_timeout": 2000
        }
      ],
      "passes": [],
      "failures": [],
      "pending": [],
      "skipped": [],
      "duration": 0,
      "root": true,
      "rootEmpty": true,
      "_timeout": 2000
    },
    {
      "uuid": "7c66a23d-7fd7-4811-9033-7f6549ec03ed",
      "title": "",
      "fullFile": "cypress/e2e/tests/comments.feature",
      "file": "cypress/e2e/tests/comments.feature",
      "beforeHooks": [],
      "afterHooks": [],
      "tests": [],
      "suites": [
        {
          "uuid": "44dc8c74-399f-4358-b189-c466e98ba0c7",
          "title": "telnyx.com",
          "fullFile": "",
          "file": "",
          "beforeHooks": [],
          "afterHooks": [],
          "tests": [
            {
              "title": "A8 - Checking the ability to switch customers' comments",
              "fullTitle": "telnyx.com A8 - Checking the ability to switch customers' comments",
              "timedOut": null,
              "duration": 3356,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {},
              "uuid": "7b2aa708-b2b4-4fc0-bbf0-a52d9854d081",
              "parentUUID": "44dc8c74-399f-4358-b189-c466e98ba0c7",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "A12 - Checking the ability to switch customers' comments",
              "fullTitle": "telnyx.com A12 - Checking the ability to switch customers' comments",
              "timedOut": null,
              "duration": 11153,
              "state": "passed",
              "speed": "slow",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {},
              "uuid": "0ea6bd94-0ded-41c5-aa96-781432f8a52c",
              "parentUUID": "44dc8c74-399f-4358-b189-c466e98ba0c7",
              "isHook": false,
              "skipped": false
            }
          ],
          "suites": [],
          "passes": [
            "7b2aa708-b2b4-4fc0-bbf0-a52d9854d081",
            "0ea6bd94-0ded-41c5-aa96-781432f8a52c"
          ],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 14509,
          "root": false,
          "rootEmpty": false,
          "_timeout": 2000
        }
      ],
      "passes": [],
      "failures": [],
      "pending": [],
      "skipped": [],
      "duration": 0,
      "root": true,
      "rootEmpty": true,
      "_timeout": 2000
    },
    {
      "uuid": "b1eb936f-41bf-4846-bb86-2c1bc0588d70",
      "title": "",
      "fullFile": "cypress/e2e/tests/comments.feature",
      "file": "cypress/e2e/tests/comments.feature",
      "beforeHooks": [],
      "afterHooks": [],
      "tests": [],
      "suites": [
        {
          "uuid": "eb9defcc-5c27-4ff8-94c8-9ea48983ec02",
          "title": "telnyx.com",
          "fullFile": "",
          "file": "",
          "beforeHooks": [],
          "afterHooks": [],
          "tests": [
            {
              "title": "A8 - Checking the ability to switch customers' comments",
              "fullTitle": "telnyx.com A8 - Checking the ability to switch customers' comments",
              "timedOut": null,
              "duration": 3925,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {},
              "uuid": "59bd68ad-b3c1-4c57-b667-c63d147f27fe",
              "parentUUID": "eb9defcc-5c27-4ff8-94c8-9ea48983ec02",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "A12 - Checking the ability to switch customers' comments",
              "fullTitle": "telnyx.com A12 - Checking the ability to switch customers' comments",
              "timedOut": null,
              "duration": 11392,
              "state": "passed",
              "speed": "slow",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {},
              "uuid": "dc2c65c1-f27c-4f26-87e1-45abee3ae841",
              "parentUUID": "eb9defcc-5c27-4ff8-94c8-9ea48983ec02",
              "isHook": false,
              "skipped": false
            }
          ],
          "suites": [],
          "passes": [
            "59bd68ad-b3c1-4c57-b667-c63d147f27fe",
            "dc2c65c1-f27c-4f26-87e1-45abee3ae841"
          ],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 15317,
          "root": false,
          "rootEmpty": false,
          "_timeout": 2000
        }
      ],
      "passes": [],
      "failures": [],
      "pending": [],
      "skipped": [],
      "duration": 0,
      "root": true,
      "rootEmpty": true,
      "_timeout": 2000
    },
    {
      "uuid": "25761184-41f2-4a21-985f-4ef5e5f540f2",
      "title": "",
      "fullFile": "cypress/e2e/tests/goToLogin.feature",
      "file": "cypress/e2e/tests/goToLogin.feature",
      "beforeHooks": [],
      "afterHooks": [],
      "tests": [],
      "suites": [
        {
          "uuid": "4f466736-6097-4153-beaf-0a69e316e070",
          "title": "telnyx.com",
          "fullFile": "",
          "file": "",
          "beforeHooks": [],
          "afterHooks": [],
          "tests": [
            {
              "title": "A11 - Checking the ability to go to the login page from the sign up page",
              "fullTitle": "telnyx.com A11 - Checking the ability to go to the login page from the sign up page",
              "timedOut": null,
              "duration": 19111,
              "state": "passed",
              "speed": "slow",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {},
              "uuid": "2b425067-57aa-480f-8d2a-9715f21eb085",
              "parentUUID": "4f466736-6097-4153-beaf-0a69e316e070",
              "isHook": false,
              "skipped": false
            }
          ],
          "suites": [],
          "passes": [
            "2b425067-57aa-480f-8d2a-9715f21eb085"
          ],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 19111,
          "root": false,
          "rootEmpty": false,
          "_timeout": 2000
        }
      ],
      "passes": [],
      "failures": [],
      "pending": [],
      "skipped": [],
      "duration": 0,
      "root": true,
      "rootEmpty": true,
      "_timeout": 2000
    },
    {
      "uuid": "4a929dda-4d47-4bb8-9874-63aa1c52ecb1",
      "title": "",
      "fullFile": "cypress/e2e/tests/customerStory.feature",
      "file": "cypress/e2e/tests/customerStory.feature",
      "beforeHooks": [],
      "afterHooks": [],
      "tests": [],
      "suites": [
        {
          "uuid": "96807a18-c72b-4c15-864e-c61c256bb454",
          "title": "telnyx.com",
          "fullFile": "",
          "file": "",
          "beforeHooks": [],
          "afterHooks": [],
          "tests": [
            {
              "title": "A4 - Checking the ability to read customers stories",
              "fullTitle": "telnyx.com A4 - Checking the ability to read customers stories",
              "timedOut": null,
              "duration": 6117,
              "state": "passed",
              "speed": "medium",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {},
              "uuid": "cfe9214b-e366-40ee-a265-a91aedeaf208",
              "parentUUID": "96807a18-c72b-4c15-864e-c61c256bb454",
              "isHook": false,
              "skipped": false
            }
          ],
          "suites": [],
          "passes": [
            "cfe9214b-e366-40ee-a265-a91aedeaf208"
          ],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 6117,
          "root": false,
          "rootEmpty": false,
          "_timeout": 2000
        }
      ],
      "passes": [],
      "failures": [],
      "pending": [],
      "skipped": [],
      "duration": 0,
      "root": true,
      "rootEmpty": true,
      "_timeout": 2000
    },
    {
      "uuid": "649f0633-b933-484e-ae3c-c809d85fb4c1",
      "title": "",
      "fullFile": "cypress/e2e/tests/goToSignUp.feature",
      "file": "cypress/e2e/tests/goToSignUp.feature",
      "beforeHooks": [],
      "afterHooks": [],
      "tests": [],
      "suites": [
        {
          "uuid": "4a62de2a-81b2-48f2-bd5b-ea34df8e85ad",
          "title": "telnyx.com",
          "fullFile": "",
          "file": "",
          "beforeHooks": [],
          "afterHooks": [],
          "tests": [
            {
              "title": "A10 - Checking the ability to go to the sign up page from the login page",
              "fullTitle": "telnyx.com A10 - Checking the ability to go to the sign up page from the login page",
              "timedOut": null,
              "duration": 27371,
              "state": "passed",
              "speed": "slow",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {},
              "uuid": "d9cf03e1-b151-43dc-9bf9-f18de6a7452f",
              "parentUUID": "4a62de2a-81b2-48f2-bd5b-ea34df8e85ad",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "A14 - Checking the ability to go to the sign up page from footer",
              "fullTitle": "telnyx.com A14 - Checking the ability to go to the sign up page from footer",
              "timedOut": null,
              "duration": 4604,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {},
              "uuid": "75d6295b-1eb9-4457-adf6-21d2b0a388b1",
              "parentUUID": "4a62de2a-81b2-48f2-bd5b-ea34df8e85ad",
              "isHook": false,
              "skipped": false
            }
          ],
          "suites": [],
          "passes": [
            "d9cf03e1-b151-43dc-9bf9-f18de6a7452f",
            "75d6295b-1eb9-4457-adf6-21d2b0a388b1"
          ],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 31975,
          "root": false,
          "rootEmpty": false,
          "_timeout": 2000
        }
      ],
      "passes": [],
      "failures": [],
      "pending": [],
      "skipped": [],
      "duration": 0,
      "root": true,
      "rootEmpty": true,
      "_timeout": 2000
    },
    {
      "uuid": "9bc4376e-b502-417e-a66d-ba55df35669d",
      "title": "",
      "fullFile": "cypress/e2e/tests/goToLogin.feature",
      "file": "cypress/e2e/tests/goToLogin.feature",
      "beforeHooks": [],
      "afterHooks": [],
      "tests": [],
      "suites": [
        {
          "uuid": "0f58d3fe-95e9-47c1-9cd4-a1ad23cf4137",
          "title": "telnyx.com",
          "fullFile": "",
          "file": "",
          "beforeHooks": [],
          "afterHooks": [],
          "tests": [
            {
              "title": "A11 - Checking the ability to go to the login page from the sign up page",
              "fullTitle": "telnyx.com A11 - Checking the ability to go to the login page from the sign up page",
              "timedOut": null,
              "duration": 23508,
              "state": "passed",
              "speed": "slow",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {},
              "uuid": "226ab79e-7344-4429-acfd-053dc057e417",
              "parentUUID": "0f58d3fe-95e9-47c1-9cd4-a1ad23cf4137",
              "isHook": false,
              "skipped": false
            }
          ],
          "suites": [],
          "passes": [
            "226ab79e-7344-4429-acfd-053dc057e417"
          ],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 23508,
          "root": false,
          "rootEmpty": false,
          "_timeout": 2000
        }
      ],
      "passes": [],
      "failures": [],
      "pending": [],
      "skipped": [],
      "duration": 0,
      "root": true,
      "rootEmpty": true,
      "_timeout": 2000
    },
    {
      "uuid": "d2714cd7-55ec-4bd0-80a0-4b2eb5afcba6",
      "title": "",
      "fullFile": "cypress/e2e/tests/products.feature",
      "file": "cypress/e2e/tests/products.feature",
      "beforeHooks": [],
      "afterHooks": [],
      "tests": [],
      "suites": [
        {
          "uuid": "2d000dfe-78ac-4a20-9447-98585138fa63",
          "title": "telnyx.com",
          "fullFile": "",
          "file": "",
          "beforeHooks": [],
          "afterHooks": [],
          "tests": [
            {
              "title": "A1 - Checking that it is possible to see all products by menu",
              "fullTitle": "telnyx.com A1 - Checking that it is possible to see all products by menu",
              "timedOut": null,
              "duration": 8464,
              "state": "passed",
              "speed": "medium",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {},
              "uuid": "1eb44954-7b2d-4297-9fb8-f50275f459b2",
              "parentUUID": "2d000dfe-78ac-4a20-9447-98585138fa63",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "A2 - Checking that it is possible to see all products by the main page",
              "fullTitle": "telnyx.com A2 - Checking that it is possible to see all products by the main page",
              "timedOut": null,
              "duration": 4101,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {},
              "uuid": "f4dd4fd6-cb04-4639-b815-d9f45504f612",
              "parentUUID": "2d000dfe-78ac-4a20-9447-98585138fa63",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "A3 - Checking that it is possible to see all products by the footer",
              "fullTitle": "telnyx.com A3 - Checking that it is possible to see all products by the footer",
              "timedOut": null,
              "duration": 4695,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {},
              "uuid": "42b84f20-6183-4a9c-b146-29a7e40c548a",
              "parentUUID": "2d000dfe-78ac-4a20-9447-98585138fa63",
              "isHook": false,
              "skipped": false
            }
          ],
          "suites": [],
          "passes": [
            "1eb44954-7b2d-4297-9fb8-f50275f459b2",
            "f4dd4fd6-cb04-4639-b815-d9f45504f612",
            "42b84f20-6183-4a9c-b146-29a7e40c548a"
          ],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 17260,
          "root": false,
          "rootEmpty": false,
          "_timeout": 2000
        }
      ],
      "passes": [],
      "failures": [],
      "pending": [],
      "skipped": [],
      "duration": 0,
      "root": true,
      "rootEmpty": true,
      "_timeout": 2000
    },
    {
      "uuid": "d194e42e-114c-4ff3-b51f-7d87880a6e3c",
      "title": "",
      "fullFile": "cypress/e2e/tests/goToSignUp.feature",
      "file": "cypress/e2e/tests/goToSignUp.feature",
      "beforeHooks": [],
      "afterHooks": [],
      "tests": [],
      "suites": [
        {
          "uuid": "499d5a89-b3f6-441e-800c-d8db050c8036",
          "title": "telnyx.com",
          "fullFile": "",
          "file": "",
          "beforeHooks": [],
          "afterHooks": [],
          "tests": [
            {
              "title": "A10 - Checking the ability to go to the sign up page from the login page",
              "fullTitle": "telnyx.com A10 - Checking the ability to go to the sign up page from the login page",
              "timedOut": null,
              "duration": 24840,
              "state": "passed",
              "speed": "slow",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {},
              "uuid": "530e2ebc-f93d-4cad-acf6-37044011086a",
              "parentUUID": "499d5a89-b3f6-441e-800c-d8db050c8036",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "A14 - Checking the ability to go to the sign up page from footer",
              "fullTitle": "telnyx.com A14 - Checking the ability to go to the sign up page from footer",
              "timedOut": null,
              "duration": 5808,
              "state": "passed",
              "speed": "medium",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {},
              "uuid": "a0b7ab22-407f-4b43-9779-9098d02985f8",
              "parentUUID": "499d5a89-b3f6-441e-800c-d8db050c8036",
              "isHook": false,
              "skipped": false
            }
          ],
          "suites": [],
          "passes": [
            "530e2ebc-f93d-4cad-acf6-37044011086a",
            "a0b7ab22-407f-4b43-9779-9098d02985f8"
          ],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 30648,
          "root": false,
          "rootEmpty": false,
          "_timeout": 2000
        }
      ],
      "passes": [],
      "failures": [],
      "pending": [],
      "skipped": [],
      "duration": 0,
      "root": true,
      "rootEmpty": true,
      "_timeout": 2000
    },
    {
      "uuid": "84798877-c4a4-4de8-b8b4-43980fc7ce1b",
      "title": "",
      "fullFile": "cypress/e2e/tests/story.feature",
      "file": "cypress/e2e/tests/story.feature",
      "beforeHooks": [],
      "afterHooks": [],
      "tests": [],
      "suites": [
        {
          "uuid": "450a547a-6f33-43ab-b613-ec23b47e3ad8",
          "title": "telnyx.com",
          "fullFile": "",
          "file": "",
          "beforeHooks": [],
          "afterHooks": [],
          "tests": [
            {
              "title": "A4 - Checking the ability to read customers stories",
              "fullTitle": "telnyx.com A4 - Checking the ability to read customers stories",
              "timedOut": null,
              "duration": 6351,
              "state": "passed",
              "speed": "medium",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {},
              "uuid": "b48cff3d-4682-4290-aef7-4b9b2acb60df",
              "parentUUID": "450a547a-6f33-43ab-b613-ec23b47e3ad8",
              "isHook": false,
              "skipped": false
            }
          ],
          "suites": [],
          "passes": [
            "b48cff3d-4682-4290-aef7-4b9b2acb60df"
          ],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 6351,
          "root": false,
          "rootEmpty": false,
          "_timeout": 2000
        }
      ],
      "passes": [],
      "failures": [],
      "pending": [],
      "skipped": [],
      "duration": 0,
      "root": true,
      "rootEmpty": true,
      "_timeout": 2000
    },
    {
      "uuid": "7dc10220-9f1c-42bc-af17-75ddcb666ac2",
      "title": "",
      "fullFile": "cypress/e2e/tests/products.feature",
      "file": "cypress/e2e/tests/products.feature",
      "beforeHooks": [],
      "afterHooks": [],
      "tests": [],
      "suites": [
        {
          "uuid": "7f376471-7127-41a9-952c-d0a584d75436",
          "title": "telnyx.com",
          "fullFile": "",
          "file": "",
          "beforeHooks": [],
          "afterHooks": [],
          "tests": [
            {
              "title": "A1 - Checking that it is possible to see all products by menu",
              "fullTitle": "telnyx.com A1 - Checking that it is possible to see all products by menu",
              "timedOut": null,
              "duration": 6995,
              "state": "passed",
              "speed": "medium",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {},
              "uuid": "fcd61817-76a9-4fd0-a57b-f6e691e2a853",
              "parentUUID": "7f376471-7127-41a9-952c-d0a584d75436",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "A2 - Checking that it is possible to see all products by the main page",
              "fullTitle": "telnyx.com A2 - Checking that it is possible to see all products by the main page",
              "timedOut": null,
              "duration": 7088,
              "state": "passed",
              "speed": "medium",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {},
              "uuid": "191a299a-90b7-4778-a530-70817c2930c3",
              "parentUUID": "7f376471-7127-41a9-952c-d0a584d75436",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "A3 - Checking that it is possible to see all products by the footer",
              "fullTitle": "telnyx.com A3 - Checking that it is possible to see all products by the footer",
              "timedOut": null,
              "duration": 7021,
              "state": "passed",
              "speed": "medium",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {},
              "uuid": "0e7324f3-3625-48dd-bea7-74b750a8ba13",
              "parentUUID": "7f376471-7127-41a9-952c-d0a584d75436",
              "isHook": false,
              "skipped": false
            }
          ],
          "suites": [],
          "passes": [
            "fcd61817-76a9-4fd0-a57b-f6e691e2a853",
            "191a299a-90b7-4778-a530-70817c2930c3",
            "0e7324f3-3625-48dd-bea7-74b750a8ba13"
          ],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 21104,
          "root": false,
          "rootEmpty": false,
          "_timeout": 2000
        }
      ],
      "passes": [],
      "failures": [],
      "pending": [],
      "skipped": [],
      "duration": 0,
      "root": true,
      "rootEmpty": true,
      "_timeout": 2000
    },
    {
      "uuid": "95ed148f-be9c-4cc3-985e-80f872f88cba",
      "title": "",
      "fullFile": "cypress/e2e/tests/switchSave.feature",
      "file": "cypress/e2e/tests/switchSave.feature",
      "beforeHooks": [],
      "afterHooks": [],
      "tests": [],
      "suites": [
        {
          "uuid": "f285d68b-d0ca-4aca-bb54-5dd828d05cf3",
          "title": "telnyx.com",
          "fullFile": "",
          "file": "",
          "beforeHooks": [],
          "afterHooks": [],
          "tests": [
            {
              "title": "A5 - Checking the ability to change data by slider",
              "fullTitle": "telnyx.com A5 - Checking the ability to change data by slider",
              "timedOut": null,
              "duration": 13443,
              "state": "passed",
              "speed": "slow",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {},
              "uuid": "ee515c76-ac07-49f8-89c8-619d0617c398",
              "parentUUID": "f285d68b-d0ca-4aca-bb54-5dd828d05cf3",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "A6 - Checking the ability to change data and look at the current price",
              "fullTitle": "telnyx.com A6 - Checking the ability to change data and look at the current price",
              "timedOut": null,
              "duration": 14151,
              "state": "passed",
              "speed": "slow",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {},
              "uuid": "4d255bce-7b29-424f-9c76-4f5794316043",
              "parentUUID": "f285d68b-d0ca-4aca-bb54-5dd828d05cf3",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "A7 - Checking the ability to see how much money will be save up",
              "fullTitle": "telnyx.com A7 - Checking the ability to see how much money will be save up",
              "timedOut": null,
              "duration": 13431,
              "state": "passed",
              "speed": "slow",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {},
              "uuid": "fe21c7a7-a12f-4ddf-9ddd-3b3769df748f",
              "parentUUID": "f285d68b-d0ca-4aca-bb54-5dd828d05cf3",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "A13 - Checking the ability to go to the sign up page from 'Switch + Save with Tenlyx' section",
              "fullTitle": "telnyx.com A13 - Checking the ability to go to the sign up page from 'Switch + Save with Tenlyx' section",
              "timedOut": null,
              "duration": 8488,
              "state": "passed",
              "speed": "medium",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {},
              "uuid": "978439ad-29aa-4969-9d57-7a98c2ba38d5",
              "parentUUID": "f285d68b-d0ca-4aca-bb54-5dd828d05cf3",
              "isHook": false,
              "skipped": false
            }
          ],
          "suites": [],
          "passes": [
            "ee515c76-ac07-49f8-89c8-619d0617c398",
            "4d255bce-7b29-424f-9c76-4f5794316043",
            "fe21c7a7-a12f-4ddf-9ddd-3b3769df748f",
            "978439ad-29aa-4969-9d57-7a98c2ba38d5"
          ],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 49513,
          "root": false,
          "rootEmpty": false,
          "_timeout": 2000
        }
      ],
      "passes": [],
      "failures": [],
      "pending": [],
      "skipped": [],
      "duration": 0,
      "root": true,
      "rootEmpty": true,
      "_timeout": 2000
    },
    {
      "uuid": "a4146343-4f14-4384-8507-6d049ea7fb41",
      "title": "",
      "fullFile": "cypress/e2e/tests/switchSave.feature",
      "file": "cypress/e2e/tests/switchSave.feature",
      "beforeHooks": [],
      "afterHooks": [],
      "tests": [],
      "suites": [
        {
          "uuid": "efab44fb-4f6c-45f3-801b-1fc027dce528",
          "title": "telnyx.com",
          "fullFile": "",
          "file": "",
          "beforeHooks": [],
          "afterHooks": [],
          "tests": [
            {
              "title": "A5 - Checking the ability to change data by slider",
              "fullTitle": "telnyx.com A5 - Checking the ability to change data by slider",
              "timedOut": null,
              "duration": 12487,
              "state": "passed",
              "speed": "slow",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {},
              "uuid": "10e365c0-ca29-467f-88a0-66176cc385c7",
              "parentUUID": "efab44fb-4f6c-45f3-801b-1fc027dce528",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "A6 - Checking the ability to change data and look at the current price",
              "fullTitle": "telnyx.com A6 - Checking the ability to change data and look at the current price",
              "timedOut": null,
              "duration": 11500,
              "state": "passed",
              "speed": "slow",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {},
              "uuid": "2223fd1c-ba95-42a9-8fb8-d97ca2d52aff",
              "parentUUID": "efab44fb-4f6c-45f3-801b-1fc027dce528",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "A7 - Checking the ability to see how much money will be save up",
              "fullTitle": "telnyx.com A7 - Checking the ability to see how much money will be save up",
              "timedOut": null,
              "duration": 10872,
              "state": "passed",
              "speed": "slow",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {},
              "uuid": "295e2e02-2ab1-4100-9ead-802e97e68eb9",
              "parentUUID": "efab44fb-4f6c-45f3-801b-1fc027dce528",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "A13 - Checking the ability to go to the sign up page from 'Switch + Save with Tenlyx' section",
              "fullTitle": "telnyx.com A13 - Checking the ability to go to the sign up page from 'Switch + Save with Tenlyx' section",
              "timedOut": null,
              "duration": 8375,
              "state": "passed",
              "speed": "medium",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {},
              "uuid": "e33ffe14-9f5f-4351-8861-7a224c94b77f",
              "parentUUID": "efab44fb-4f6c-45f3-801b-1fc027dce528",
              "isHook": false,
              "skipped": false
            }
          ],
          "suites": [],
          "passes": [
            "10e365c0-ca29-467f-88a0-66176cc385c7",
            "2223fd1c-ba95-42a9-8fb8-d97ca2d52aff",
            "295e2e02-2ab1-4100-9ead-802e97e68eb9",
            "e33ffe14-9f5f-4351-8861-7a224c94b77f"
          ],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 43234,
          "root": false,
          "rootEmpty": false,
          "_timeout": 2000
        }
      ],
      "passes": [],
      "failures": [],
      "pending": [],
      "skipped": [],
      "duration": 0,
      "root": true,
      "rootEmpty": true,
      "_timeout": 2000
    },
    {
      "uuid": "02b282c1-8568-4773-842e-4e5258afb3e1",
      "title": "",
      "fullFile": "cypress/e2e/tests/twitter.feature",
      "file": "cypress/e2e/tests/twitter.feature",
      "beforeHooks": [],
      "afterHooks": [],
      "tests": [],
      "suites": [
        {
          "uuid": "9f5d4a69-8ee6-41db-9401-4fd113ebbae5",
          "title": "telnyx.com",
          "fullFile": "",
          "file": "",
          "beforeHooks": [],
          "afterHooks": [],
          "tests": [
            {
              "title": "A15 -  Check that the site is linked with Twitter",
              "fullTitle": "telnyx.com A15 -  Check that the site is linked with Twitter",
              "timedOut": null,
              "duration": 6764,
              "state": "passed",
              "speed": "medium",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {},
              "uuid": "17270aa5-9ae2-40ef-8dde-d16c12f7392b",
              "parentUUID": "9f5d4a69-8ee6-41db-9401-4fd113ebbae5",
              "isHook": false,
              "skipped": false
            }
          ],
          "suites": [],
          "passes": [
            "17270aa5-9ae2-40ef-8dde-d16c12f7392b"
          ],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 6764,
          "root": false,
          "rootEmpty": false,
          "_timeout": 2000
        }
      ],
      "passes": [],
      "failures": [],
      "pending": [],
      "skipped": [],
      "duration": 0,
      "root": true,
      "rootEmpty": true,
      "_timeout": 2000
    },
    {
      "uuid": "9ab15783-163e-4cd9-b6d5-475bf03972aa",
      "title": "",
      "fullFile": "cypress/e2e/tests/twitter.feature",
      "file": "cypress/e2e/tests/twitter.feature",
      "beforeHooks": [],
      "afterHooks": [],
      "tests": [],
      "suites": [
        {
          "uuid": "e02bae35-da00-4aeb-b646-5b77f19dd010",
          "title": "telnyx.com",
          "fullFile": "",
          "file": "",
          "beforeHooks": [],
          "afterHooks": [],
          "tests": [
            {
              "title": "A15 -  Check that the site is linked with Twitter",
              "fullTitle": "telnyx.com A15 -  Check that the site is linked with Twitter",
              "timedOut": null,
              "duration": 8045,
              "state": "passed",
              "speed": "medium",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {},
              "uuid": "7bbe38d4-f180-456d-8987-c8137cba9875",
              "parentUUID": "e02bae35-da00-4aeb-b646-5b77f19dd010",
              "isHook": false,
              "skipped": false
            }
          ],
          "suites": [],
          "passes": [
            "7bbe38d4-f180-456d-8987-c8137cba9875"
          ],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 8045,
          "root": false,
          "rootEmpty": false,
          "_timeout": 2000
        }
      ],
      "passes": [],
      "failures": [],
      "pending": [],
      "skipped": [],
      "duration": 0,
      "root": true,
      "rootEmpty": true,
      "_timeout": 2000
    },
    {
      "uuid": "f1e3b3e6-06dc-46d6-b21d-6c18626135da",
      "title": "",
      "fullFile": "cypress/e2e/tests/API.feature",
      "file": "cypress/e2e/tests/API.feature",
      "beforeHooks": [],
      "afterHooks": [],
      "tests": [],
      "suites": [
        {
          "uuid": "6964e10b-dcdf-4a9f-9b8f-b5b9e8456d40",
          "title": "telnyx.com",
          "fullFile": "",
          "file": "",
          "beforeHooks": [],
          "afterHooks": [],
          "tests": [
            {
              "title": "A9 - Checking the ability to learn more about API documentation",
              "fullTitle": "telnyx.com A9 - Checking the ability to learn more about API documentation",
              "timedOut": null,
              "duration": 14343,
              "state": "passed",
              "speed": "slow",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {},
              "uuid": "b0f2cf23-e027-40d1-b5d8-61a6fe0f6fdc",
              "parentUUID": "6964e10b-dcdf-4a9f-9b8f-b5b9e8456d40",
              "isHook": false,
              "skipped": false
            }
          ],
          "suites": [],
          "passes": [
            "b0f2cf23-e027-40d1-b5d8-61a6fe0f6fdc"
          ],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 14343,
          "root": false,
          "rootEmpty": false,
          "_timeout": 2000
        }
      ],
      "passes": [],
      "failures": [],
      "pending": [],
      "skipped": [],
      "duration": 0,
      "root": true,
      "rootEmpty": true,
      "_timeout": 2000
    },
    {
      "uuid": "96ac7dde-cfa3-446d-be7f-271ca84007d5",
      "title": "",
      "fullFile": "cypress/e2e/tests/comments.feature",
      "file": "cypress/e2e/tests/comments.feature",
      "beforeHooks": [],
      "afterHooks": [],
      "tests": [],
      "suites": [
        {
          "uuid": "3b9403a9-796e-425e-bcfb-bcced81a6e51",
          "title": "telnyx.com",
          "fullFile": "",
          "file": "",
          "beforeHooks": [],
          "afterHooks": [],
          "tests": [
            {
              "title": "A8 - Checking the ability to switch customers' comments",
              "fullTitle": "telnyx.com A8 - Checking the ability to switch customers' comments",
              "timedOut": null,
              "duration": 4642,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {},
              "uuid": "905f7be6-93c0-4569-929b-42cf75d97513",
              "parentUUID": "3b9403a9-796e-425e-bcfb-bcced81a6e51",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "A12 - Checking the ability to switch customers' comments",
              "fullTitle": "telnyx.com A12 - Checking the ability to switch customers' comments",
              "timedOut": null,
              "duration": 11041,
              "state": "passed",
              "speed": "slow",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {},
              "uuid": "1905fb24-db5d-494f-b0d6-a2cd7d329a0c",
              "parentUUID": "3b9403a9-796e-425e-bcfb-bcced81a6e51",
              "isHook": false,
              "skipped": false
            }
          ],
          "suites": [],
          "passes": [
            "905f7be6-93c0-4569-929b-42cf75d97513",
            "1905fb24-db5d-494f-b0d6-a2cd7d329a0c"
          ],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 15683,
          "root": false,
          "rootEmpty": false,
          "_timeout": 2000
        }
      ],
      "passes": [],
      "failures": [],
      "pending": [],
      "skipped": [],
      "duration": 0,
      "root": true,
      "rootEmpty": true,
      "_timeout": 2000
    },
    {
      "uuid": "fb5323d8-430d-48a9-a0b9-9783b2f3b007",
      "title": "",
      "fullFile": "cypress/e2e/tests/goToLogin.feature",
      "file": "cypress/e2e/tests/goToLogin.feature",
      "beforeHooks": [],
      "afterHooks": [],
      "tests": [],
      "suites": [
        {
          "uuid": "8cac6d31-d029-4558-beb2-e00848568b41",
          "title": "telnyx.com",
          "fullFile": "",
          "file": "",
          "beforeHooks": [],
          "afterHooks": [],
          "tests": [
            {
              "title": "A11 - Checking the ability to go to the login page from the sign up page",
              "fullTitle": "telnyx.com A11 - Checking the ability to go to the login page from the sign up page",
              "timedOut": null,
              "duration": 32786,
              "state": "passed",
              "speed": "slow",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {},
              "uuid": "d60cf4d5-6da0-475e-bd8b-f2e485f1535a",
              "parentUUID": "8cac6d31-d029-4558-beb2-e00848568b41",
              "isHook": false,
              "skipped": false
            }
          ],
          "suites": [],
          "passes": [
            "d60cf4d5-6da0-475e-bd8b-f2e485f1535a"
          ],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 32786,
          "root": false,
          "rootEmpty": false,
          "_timeout": 2000
        }
      ],
      "passes": [],
      "failures": [],
      "pending": [],
      "skipped": [],
      "duration": 0,
      "root": true,
      "rootEmpty": true,
      "_timeout": 2000
    },
    {
      "uuid": "417898b2-b36b-4c83-8dee-0d47a9e020cc",
      "title": "",
      "fullFile": "cypress/e2e/tests/goToSignUp.feature",
      "file": "cypress/e2e/tests/goToSignUp.feature",
      "beforeHooks": [],
      "afterHooks": [],
      "tests": [],
      "suites": [
        {
          "uuid": "a07d17e8-0af8-4868-bc56-c439ac69e0d2",
          "title": "telnyx.com",
          "fullFile": "",
          "file": "",
          "beforeHooks": [],
          "afterHooks": [],
          "tests": [
            {
              "title": "A10 - Checking the ability to go to the sign up page from the login page",
              "fullTitle": "telnyx.com A10 - Checking the ability to go to the sign up page from the login page",
              "timedOut": null,
              "duration": 30768,
              "state": "passed",
              "speed": "slow",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {},
              "uuid": "e56da369-caaf-464e-9500-abcfa554df4f",
              "parentUUID": "a07d17e8-0af8-4868-bc56-c439ac69e0d2",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "A14 - Checking the ability to go to the sign up page from footer",
              "fullTitle": "telnyx.com A14 - Checking the ability to go to the sign up page from footer",
              "timedOut": null,
              "duration": 6705,
              "state": "passed",
              "speed": "medium",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {},
              "uuid": "b9c0f768-67df-48f5-a3fb-a0f347d720cb",
              "parentUUID": "a07d17e8-0af8-4868-bc56-c439ac69e0d2",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "A13 - Checking the ability to go to the sign up page from 'Switch + Save with Tenlyx' section",
              "fullTitle": "telnyx.com A13 - Checking the ability to go to the sign up page from 'Switch + Save with Tenlyx' section",
              "timedOut": null,
              "duration": 14806,
              "state": "passed",
              "speed": "slow",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {},
              "uuid": "ef89f8e7-4dce-4c16-81ec-bdc4e9949cd9",
              "parentUUID": "a07d17e8-0af8-4868-bc56-c439ac69e0d2",
              "isHook": false,
              "skipped": false
            }
          ],
          "suites": [],
          "passes": [
            "e56da369-caaf-464e-9500-abcfa554df4f",
            "b9c0f768-67df-48f5-a3fb-a0f347d720cb",
            "ef89f8e7-4dce-4c16-81ec-bdc4e9949cd9"
          ],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 52279,
          "root": false,
          "rootEmpty": false,
          "_timeout": 2000
        }
      ],
      "passes": [],
      "failures": [],
      "pending": [],
      "skipped": [],
      "duration": 0,
      "root": true,
      "rootEmpty": true,
      "_timeout": 2000
    },
    {
      "uuid": "c7f3a6b0-ab48-4169-ace1-7845ba971725",
      "title": "",
      "fullFile": "cypress/e2e/tests/products.feature",
      "file": "cypress/e2e/tests/products.feature",
      "beforeHooks": [],
      "afterHooks": [],
      "tests": [],
      "suites": [
        {
          "uuid": "c77a2b01-1e8c-4ee3-b4b8-34b4ff8de840",
          "title": "telnyx.com",
          "fullFile": "",
          "file": "",
          "beforeHooks": [],
          "afterHooks": [],
          "tests": [
            {
              "title": "A1 - Checking that it is possible to see all products by menu",
              "fullTitle": "telnyx.com A1 - Checking that it is possible to see all products by menu",
              "timedOut": null,
              "duration": 10662,
              "state": "passed",
              "speed": "slow",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {},
              "uuid": "6654e599-5ea4-4e1f-a319-ce7d47608128",
              "parentUUID": "c77a2b01-1e8c-4ee3-b4b8-34b4ff8de840",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "A2 - Checking that it is possible to see all products by the main page",
              "fullTitle": "telnyx.com A2 - Checking that it is possible to see all products by the main page",
              "timedOut": null,
              "duration": 5690,
              "state": "passed",
              "speed": "medium",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {},
              "uuid": "3062c05b-80a9-41a6-b00c-4be1d6e971a1",
              "parentUUID": "c77a2b01-1e8c-4ee3-b4b8-34b4ff8de840",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "A3 - Checking that it is possible to see all products by the footer",
              "fullTitle": "telnyx.com A3 - Checking that it is possible to see all products by the footer",
              "timedOut": null,
              "duration": 5861,
              "state": "passed",
              "speed": "medium",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {},
              "uuid": "9d1ca682-d9a1-4383-adf4-c64e8bae60e5",
              "parentUUID": "c77a2b01-1e8c-4ee3-b4b8-34b4ff8de840",
              "isHook": false,
              "skipped": false
            }
          ],
          "suites": [],
          "passes": [
            "6654e599-5ea4-4e1f-a319-ce7d47608128",
            "3062c05b-80a9-41a6-b00c-4be1d6e971a1",
            "9d1ca682-d9a1-4383-adf4-c64e8bae60e5"
          ],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 22213,
          "root": false,
          "rootEmpty": false,
          "_timeout": 2000
        }
      ],
      "passes": [],
      "failures": [],
      "pending": [],
      "skipped": [],
      "duration": 0,
      "root": true,
      "rootEmpty": true,
      "_timeout": 2000
    },
    {
      "uuid": "cd572eed-1710-4a59-9f17-096ab83bbaa7",
      "title": "",
      "fullFile": "cypress/e2e/tests/story.feature",
      "file": "cypress/e2e/tests/story.feature",
      "beforeHooks": [],
      "afterHooks": [],
      "tests": [],
      "suites": [
        {
          "uuid": "f6be55eb-e8ee-4c4a-803f-4de3193ab909",
          "title": "telnyx.com",
          "fullFile": "",
          "file": "",
          "beforeHooks": [],
          "afterHooks": [],
          "tests": [
            {
              "title": "A4 - Checking the ability to read customers stories",
              "fullTitle": "telnyx.com A4 - Checking the ability to read customers stories",
              "timedOut": null,
              "duration": 9663,
              "state": "passed",
              "speed": "medium",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {},
              "uuid": "a9ecc70b-ea06-466f-aae0-56d5ccc47f4b",
              "parentUUID": "f6be55eb-e8ee-4c4a-803f-4de3193ab909",
              "isHook": false,
              "skipped": false
            }
          ],
          "suites": [],
          "passes": [
            "a9ecc70b-ea06-466f-aae0-56d5ccc47f4b"
          ],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 9663,
          "root": false,
          "rootEmpty": false,
          "_timeout": 2000
        }
      ],
      "passes": [],
      "failures": [],
      "pending": [],
      "skipped": [],
      "duration": 0,
      "root": true,
      "rootEmpty": true,
      "_timeout": 2000
    },
    {
      "uuid": "1c94cb5c-a802-48f8-8eae-cdfa433a9772",
      "title": "",
      "fullFile": "cypress/e2e/tests/switchSave.feature",
      "file": "cypress/e2e/tests/switchSave.feature",
      "beforeHooks": [],
      "afterHooks": [],
      "tests": [],
      "suites": [
        {
          "uuid": "bab768a5-408b-4658-976d-5e93563d259e",
          "title": "telnyx.com",
          "fullFile": "",
          "file": "",
          "beforeHooks": [],
          "afterHooks": [],
          "tests": [
            {
              "title": "A5 - Checking the ability to change data by slider",
              "fullTitle": "telnyx.com A5 - Checking the ability to change data by slider",
              "timedOut": null,
              "duration": 11466,
              "state": "failed",
              "speed": null,
              "pass": false,
              "fail": true,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {
                "message": "TypeError: Cannot read properties of undefined (reading 'makeCallsAmount')",
                "estack": "TypeError: Cannot read properties of undefined (reading 'makeCallsAmount')\n    at Context.eval (cypress/e2e/tests/switchSave.js:22:20)\n    at Registry.runStepDefininition (node_modules/@badeball/cypress-cucumber-preprocessor/lib/registry.js:119:0)\n    at Context.eval (node_modules/@badeball/cypress-cucumber-preprocessor/lib/create-tests.js:291:0)",
                "diff": null
              },
              "uuid": "e66fe947-40b4-4e60-b895-efe80df5431f",
              "parentUUID": "bab768a5-408b-4658-976d-5e93563d259e",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "A6 - Checking the ability to change data and look at the current price",
              "fullTitle": "telnyx.com A6 - Checking the ability to change data and look at the current price",
              "timedOut": null,
              "duration": 10407,
              "state": "failed",
              "speed": null,
              "pass": false,
              "fail": true,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {
                "message": "TypeError: Cannot read properties of undefined (reading 'totalPriceTelnyx')",
                "estack": "TypeError: Cannot read properties of undefined (reading 'totalPriceTelnyx')\n    at Context.eval (cypress/e2e/tests/switchSave.js:45:22)\n    at Registry.runStepDefininition (node_modules/@badeball/cypress-cucumber-preprocessor/lib/registry.js:119:0)\n    at Context.eval (node_modules/@badeball/cypress-cucumber-preprocessor/lib/create-tests.js:291:0)",
                "diff": null
              },
              "uuid": "f59b0abb-7bbb-41b8-8b18-ff424cac29e9",
              "parentUUID": "bab768a5-408b-4658-976d-5e93563d259e",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "A7 - Checking the ability to see how much money will be save up",
              "fullTitle": "telnyx.com A7 - Checking the ability to see how much money will be save up",
              "timedOut": null,
              "duration": 9362,
              "state": "failed",
              "speed": null,
              "pass": false,
              "fail": true,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {
                "message": "TypeError: Cannot read properties of undefined (reading 'totalPriceTelnyx')",
                "estack": "TypeError: Cannot read properties of undefined (reading 'totalPriceTelnyx')\n    at Context.eval (cypress/e2e/tests/switchSave.js:52:20)\n    at Registry.runStepDefininition (node_modules/@badeball/cypress-cucumber-preprocessor/lib/registry.js:119:0)\n    at Context.eval (node_modules/@badeball/cypress-cucumber-preprocessor/lib/create-tests.js:291:0)",
                "diff": null
              },
              "uuid": "0411e955-b0b4-4c10-b9ff-c08d3d89c6f6",
              "parentUUID": "bab768a5-408b-4658-976d-5e93563d259e",
              "isHook": false,
              "skipped": false
            }
          ],
          "suites": [],
          "passes": [],
          "failures": [
            "e66fe947-40b4-4e60-b895-efe80df5431f",
            "f59b0abb-7bbb-41b8-8b18-ff424cac29e9",
            "0411e955-b0b4-4c10-b9ff-c08d3d89c6f6"
          ],
          "pending": [],
          "skipped": [],
          "duration": 31235,
          "root": false,
          "rootEmpty": false,
          "_timeout": 2000
        }
      ],
      "passes": [],
      "failures": [],
      "pending": [],
      "skipped": [],
      "duration": 0,
      "root": true,
      "rootEmpty": true,
      "_timeout": 2000
    },
    {
      "uuid": "27a33d40-a369-48ba-b7a5-d3a414845878",
      "title": "",
      "fullFile": "cypress/e2e/tests/twitter.feature",
      "file": "cypress/e2e/tests/twitter.feature",
      "beforeHooks": [],
      "afterHooks": [],
      "tests": [],
      "suites": [
        {
          "uuid": "523b7cac-9a2d-41c3-842a-32ec14c58726",
          "title": "telnyx.com",
          "fullFile": "",
          "file": "",
          "beforeHooks": [],
          "afterHooks": [],
          "tests": [
            {
              "title": "A15 -  Check that the site is linked with Twitter",
              "fullTitle": "telnyx.com A15 -  Check that the site is linked with Twitter",
              "timedOut": null,
              "duration": 6956,
              "state": "passed",
              "speed": "medium",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {},
              "uuid": "25439644-71f3-4168-a9e2-7a3444f0cad0",
              "parentUUID": "523b7cac-9a2d-41c3-842a-32ec14c58726",
              "isHook": false,
              "skipped": false
            }
          ],
          "suites": [],
          "passes": [
            "25439644-71f3-4168-a9e2-7a3444f0cad0"
          ],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 6956,
          "root": false,
          "rootEmpty": false,
          "_timeout": 2000
        }
      ],
      "passes": [],
      "failures": [],
      "pending": [],
      "skipped": [],
      "duration": 0,
      "root": true,
      "rootEmpty": true,
      "_timeout": 2000
    },
    {
      "uuid": "298326ba-e3f0-445d-96e3-6e6fad4ef9c4",
      "title": "",
      "fullFile": "cypress/e2e/tests/API.feature",
      "file": "cypress/e2e/tests/API.feature",
      "beforeHooks": [],
      "afterHooks": [],
      "tests": [],
      "suites": [
        {
          "uuid": "084f2fbc-9c8f-496d-9974-1ea52233dbbc",
          "title": "telnyx.com",
          "fullFile": "",
          "file": "",
          "beforeHooks": [],
          "afterHooks": [],
          "tests": [
            {
              "title": "A9 - Checking the ability to learn more about API documentation",
              "fullTitle": "telnyx.com A9 - Checking the ability to learn more about API documentation",
              "timedOut": null,
              "duration": 16266,
              "state": "passed",
              "speed": "slow",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {},
              "uuid": "0876b99b-02c4-40e6-8d64-39b1b3b2895f",
              "parentUUID": "084f2fbc-9c8f-496d-9974-1ea52233dbbc",
              "isHook": false,
              "skipped": false
            }
          ],
          "suites": [],
          "passes": [
            "0876b99b-02c4-40e6-8d64-39b1b3b2895f"
          ],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 16266,
          "root": false,
          "rootEmpty": false,
          "_timeout": 2000
        }
      ],
      "passes": [],
      "failures": [],
      "pending": [],
      "skipped": [],
      "duration": 0,
      "root": true,
      "rootEmpty": true,
      "_timeout": 2000
    },
    {
      "uuid": "06abb04c-6b8f-4a9d-9040-ed09486bb612",
      "title": "",
      "fullFile": "cypress/e2e/tests/comments.feature",
      "file": "cypress/e2e/tests/comments.feature",
      "beforeHooks": [],
      "afterHooks": [],
      "tests": [],
      "suites": [
        {
          "uuid": "e7aa3316-12e5-497f-8b1f-a3b4659be14f",
          "title": "telnyx.com",
          "fullFile": "",
          "file": "",
          "beforeHooks": [],
          "afterHooks": [],
          "tests": [
            {
              "title": "A8 - Checking the ability to switch customers' comments",
              "fullTitle": "telnyx.com A8 - Checking the ability to switch customers' comments",
              "timedOut": null,
              "duration": 5114,
              "state": "passed",
              "speed": "medium",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {},
              "uuid": "d41fde83-8cf8-42f7-ba92-a6964f738f0b",
              "parentUUID": "e7aa3316-12e5-497f-8b1f-a3b4659be14f",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "A12 - Checking the ability to switch customers' comments",
              "fullTitle": "telnyx.com A12 - Checking the ability to switch customers' comments",
              "timedOut": null,
              "duration": 11542,
              "state": "passed",
              "speed": "slow",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {},
              "uuid": "7a9a304f-ed5b-4508-85c6-a61c5bab3947",
              "parentUUID": "e7aa3316-12e5-497f-8b1f-a3b4659be14f",
              "isHook": false,
              "skipped": false
            }
          ],
          "suites": [],
          "passes": [
            "d41fde83-8cf8-42f7-ba92-a6964f738f0b",
            "7a9a304f-ed5b-4508-85c6-a61c5bab3947"
          ],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 16656,
          "root": false,
          "rootEmpty": false,
          "_timeout": 2000
        }
      ],
      "passes": [],
      "failures": [],
      "pending": [],
      "skipped": [],
      "duration": 0,
      "root": true,
      "rootEmpty": true,
      "_timeout": 2000
    },
    {
      "uuid": "65be0a1a-5b9e-4d40-bcba-22413963fde3",
      "title": "",
      "fullFile": "cypress/e2e/tests/goToLogin.feature",
      "file": "cypress/e2e/tests/goToLogin.feature",
      "beforeHooks": [],
      "afterHooks": [],
      "tests": [],
      "suites": [
        {
          "uuid": "85c835d3-e801-4065-8a6c-757918a24552",
          "title": "telnyx.com",
          "fullFile": "",
          "file": "",
          "beforeHooks": [],
          "afterHooks": [],
          "tests": [
            {
              "title": "A11 - Checking the ability to go to the login page from the sign up page",
              "fullTitle": "telnyx.com A11 - Checking the ability to go to the login page from the sign up page",
              "timedOut": null,
              "duration": 29980,
              "state": "passed",
              "speed": "slow",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {},
              "uuid": "f796c298-f254-4692-a2df-19a72508f7f2",
              "parentUUID": "85c835d3-e801-4065-8a6c-757918a24552",
              "isHook": false,
              "skipped": false
            }
          ],
          "suites": [],
          "passes": [
            "f796c298-f254-4692-a2df-19a72508f7f2"
          ],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 29980,
          "root": false,
          "rootEmpty": false,
          "_timeout": 2000
        }
      ],
      "passes": [],
      "failures": [],
      "pending": [],
      "skipped": [],
      "duration": 0,
      "root": true,
      "rootEmpty": true,
      "_timeout": 2000
    },
    {
      "uuid": "0ff4fbd2-bf20-422b-ad55-9f42ed46a099",
      "title": "",
      "fullFile": "cypress/e2e/tests/goToSignUp.feature",
      "file": "cypress/e2e/tests/goToSignUp.feature",
      "beforeHooks": [],
      "afterHooks": [],
      "tests": [],
      "suites": [
        {
          "uuid": "0fa03f04-368c-49dd-b14f-40f77b7ddebc",
          "title": "telnyx.com",
          "fullFile": "",
          "file": "",
          "beforeHooks": [],
          "afterHooks": [],
          "tests": [
            {
              "title": "A10 - Checking the ability to go to the sign up page from the login page",
              "fullTitle": "telnyx.com A10 - Checking the ability to go to the sign up page from the login page",
              "timedOut": null,
              "duration": 25229,
              "state": "passed",
              "speed": "slow",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {},
              "uuid": "11d28801-194c-4545-b98d-6362cb786481",
              "parentUUID": "0fa03f04-368c-49dd-b14f-40f77b7ddebc",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "A14 - Checking the ability to go to the sign up page from footer",
              "fullTitle": "telnyx.com A14 - Checking the ability to go to the sign up page from footer",
              "timedOut": null,
              "duration": 6417,
              "state": "passed",
              "speed": "medium",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {},
              "uuid": "6e3f6ee8-dd92-44de-88e8-111c8b39bd71",
              "parentUUID": "0fa03f04-368c-49dd-b14f-40f77b7ddebc",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "A13 - Checking the ability to go to the sign up page from 'Switch + Save with Tenlyx' section",
              "fullTitle": "telnyx.com A13 - Checking the ability to go to the sign up page from 'Switch + Save with Tenlyx' section",
              "timedOut": null,
              "duration": 8546,
              "state": "passed",
              "speed": "medium",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {},
              "uuid": "ad31276b-af5e-4e11-938d-c22357d94a2c",
              "parentUUID": "0fa03f04-368c-49dd-b14f-40f77b7ddebc",
              "isHook": false,
              "skipped": false
            }
          ],
          "suites": [],
          "passes": [
            "11d28801-194c-4545-b98d-6362cb786481",
            "6e3f6ee8-dd92-44de-88e8-111c8b39bd71",
            "ad31276b-af5e-4e11-938d-c22357d94a2c"
          ],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 40192,
          "root": false,
          "rootEmpty": false,
          "_timeout": 2000
        }
      ],
      "passes": [],
      "failures": [],
      "pending": [],
      "skipped": [],
      "duration": 0,
      "root": true,
      "rootEmpty": true,
      "_timeout": 2000
    },
    {
      "uuid": "31288621-22db-4207-91dd-8dbd46f865d8",
      "title": "",
      "fullFile": "cypress/e2e/tests/products.feature",
      "file": "cypress/e2e/tests/products.feature",
      "beforeHooks": [],
      "afterHooks": [],
      "tests": [],
      "suites": [
        {
          "uuid": "d215c10b-5aba-42ba-8606-cb898c00da18",
          "title": "telnyx.com",
          "fullFile": "",
          "file": "",
          "beforeHooks": [],
          "afterHooks": [],
          "tests": [
            {
              "title": "A1 - Checking that it is possible to see all products by menu",
              "fullTitle": "telnyx.com A1 - Checking that it is possible to see all products by menu",
              "timedOut": null,
              "duration": 10164,
              "state": "passed",
              "speed": "slow",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {},
              "uuid": "73ae35d2-54d3-4863-a1dd-f52478211880",
              "parentUUID": "d215c10b-5aba-42ba-8606-cb898c00da18",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "A2 - Checking that it is possible to see all products by the main page",
              "fullTitle": "telnyx.com A2 - Checking that it is possible to see all products by the main page",
              "timedOut": null,
              "duration": 7299,
              "state": "passed",
              "speed": "medium",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {},
              "uuid": "f623885b-cfa8-45fe-b58c-de9103545937",
              "parentUUID": "d215c10b-5aba-42ba-8606-cb898c00da18",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "A3 - Checking that it is possible to see all products by the footer",
              "fullTitle": "telnyx.com A3 - Checking that it is possible to see all products by the footer",
              "timedOut": null,
              "duration": 6276,
              "state": "passed",
              "speed": "medium",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {},
              "uuid": "b55beea6-69cb-459c-bae8-c83106231bb9",
              "parentUUID": "d215c10b-5aba-42ba-8606-cb898c00da18",
              "isHook": false,
              "skipped": false
            }
          ],
          "suites": [],
          "passes": [
            "73ae35d2-54d3-4863-a1dd-f52478211880",
            "f623885b-cfa8-45fe-b58c-de9103545937",
            "b55beea6-69cb-459c-bae8-c83106231bb9"
          ],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 23739,
          "root": false,
          "rootEmpty": false,
          "_timeout": 2000
        }
      ],
      "passes": [],
      "failures": [],
      "pending": [],
      "skipped": [],
      "duration": 0,
      "root": true,
      "rootEmpty": true,
      "_timeout": 2000
    },
    {
      "uuid": "fc638d72-1968-4bc9-95f6-6d8aa07d817f",
      "title": "",
      "fullFile": "cypress/e2e/tests/story.feature",
      "file": "cypress/e2e/tests/story.feature",
      "beforeHooks": [],
      "afterHooks": [],
      "tests": [],
      "suites": [
        {
          "uuid": "547fddf6-49d1-4933-9d6d-6d35b909b307",
          "title": "telnyx.com",
          "fullFile": "",
          "file": "",
          "beforeHooks": [],
          "afterHooks": [],
          "tests": [
            {
              "title": "A4 - Checking the ability to read customers stories",
              "fullTitle": "telnyx.com A4 - Checking the ability to read customers stories",
              "timedOut": null,
              "duration": 6393,
              "state": "passed",
              "speed": "medium",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {},
              "uuid": "dd912014-47c9-4ac6-98ec-4fbbd89780bc",
              "parentUUID": "547fddf6-49d1-4933-9d6d-6d35b909b307",
              "isHook": false,
              "skipped": false
            }
          ],
          "suites": [],
          "passes": [
            "dd912014-47c9-4ac6-98ec-4fbbd89780bc"
          ],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 6393,
          "root": false,
          "rootEmpty": false,
          "_timeout": 2000
        }
      ],
      "passes": [],
      "failures": [],
      "pending": [],
      "skipped": [],
      "duration": 0,
      "root": true,
      "rootEmpty": true,
      "_timeout": 2000
    },
    {
      "uuid": "64c79534-2ff9-480a-966a-d15cb12ce606",
      "title": "",
      "fullFile": "cypress/e2e/tests/switchSave.feature",
      "file": "cypress/e2e/tests/switchSave.feature",
      "beforeHooks": [],
      "afterHooks": [],
      "tests": [],
      "suites": [
        {
          "uuid": "33e8a48d-6d95-4aa6-b7d3-fb85a1a74d60",
          "title": "telnyx.com",
          "fullFile": "",
          "file": "",
          "beforeHooks": [],
          "afterHooks": [],
          "tests": [
            {
              "title": "A5 - Checking the ability to change data by slider",
              "fullTitle": "telnyx.com A5 - Checking the ability to change data by slider",
              "timedOut": null,
              "duration": 11104,
              "state": "failed",
              "speed": null,
              "pass": false,
              "fail": true,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {
                "message": "ReferenceError: total_1 is not defined",
                "estack": "ReferenceError: total_1 is not defined\n    at Context.eval (cypress/e2e/tests/switchSave.js:18:11)",
                "diff": null
              },
              "uuid": "a2cb8976-4a62-4a5d-a157-c065ae9d6622",
              "parentUUID": "33e8a48d-6d95-4aa6-b7d3-fb85a1a74d60",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "A6 - Checking the ability to change data and look at the current price",
              "fullTitle": "telnyx.com A6 - Checking the ability to change data and look at the current price",
              "timedOut": null,
              "duration": 14473,
              "state": "failed",
              "speed": null,
              "pass": false,
              "fail": true,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {
                "message": "ReferenceError: total_2 is not defined",
                "estack": "ReferenceError: total_2 is not defined\n    at Context.eval (cypress/e2e/tests/switchSave.js:40:11)",
                "diff": null
              },
              "uuid": "2da483da-2f2d-4b69-bc8d-bb6c0d8f3cee",
              "parentUUID": "33e8a48d-6d95-4aa6-b7d3-fb85a1a74d60",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "A7 - Checking the ability to see how much money will be save up",
              "fullTitle": "telnyx.com A7 - Checking the ability to see how much money will be save up",
              "timedOut": null,
              "duration": 12659,
              "state": "failed",
              "speed": null,
              "pass": false,
              "fail": true,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {
                "message": "ReferenceError: totalPriceTelnyx is not defined",
                "estack": "ReferenceError: totalPriceTelnyx is not defined\n    at Context.eval (cypress/e2e/tests/switchSave.js:49:20)",
                "diff": null
              },
              "uuid": "a6a69740-29cb-4283-9505-a6dabf461729",
              "parentUUID": "33e8a48d-6d95-4aa6-b7d3-fb85a1a74d60",
              "isHook": false,
              "skipped": false
            }
          ],
          "suites": [],
          "passes": [],
          "failures": [
            "a2cb8976-4a62-4a5d-a157-c065ae9d6622",
            "2da483da-2f2d-4b69-bc8d-bb6c0d8f3cee",
            "a6a69740-29cb-4283-9505-a6dabf461729"
          ],
          "pending": [],
          "skipped": [],
          "duration": 38236,
          "root": false,
          "rootEmpty": false,
          "_timeout": 2000
        }
      ],
      "passes": [],
      "failures": [],
      "pending": [],
      "skipped": [],
      "duration": 0,
      "root": true,
      "rootEmpty": true,
      "_timeout": 2000
    },
    {
      "uuid": "8fce4221-229b-414b-897b-9e1caad5651d",
      "title": "",
      "fullFile": "cypress/e2e/tests/twitter.feature",
      "file": "cypress/e2e/tests/twitter.feature",
      "beforeHooks": [],
      "afterHooks": [],
      "tests": [],
      "suites": [
        {
          "uuid": "7cb6eb76-6870-4876-aa3b-668864078f08",
          "title": "telnyx.com",
          "fullFile": "",
          "file": "",
          "beforeHooks": [],
          "afterHooks": [],
          "tests": [
            {
              "title": "A15 -  Check that the site is linked with Twitter",
              "fullTitle": "telnyx.com A15 -  Check that the site is linked with Twitter",
              "timedOut": null,
              "duration": 8047,
              "state": "passed",
              "speed": "medium",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {},
              "uuid": "d23de391-91ce-4711-bd97-0347571caa54",
              "parentUUID": "7cb6eb76-6870-4876-aa3b-668864078f08",
              "isHook": false,
              "skipped": false
            }
          ],
          "suites": [],
          "passes": [
            "d23de391-91ce-4711-bd97-0347571caa54"
          ],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 8047,
          "root": false,
          "rootEmpty": false,
          "_timeout": 2000
        }
      ],
      "passes": [],
      "failures": [],
      "pending": [],
      "skipped": [],
      "duration": 0,
      "root": true,
      "rootEmpty": true,
      "_timeout": 2000
    },
    {
      "uuid": "0033eadb-64a6-4db6-b5b7-132211035890",
      "title": "",
      "fullFile": "cypress/e2e/tests/switchSave.feature",
      "file": "cypress/e2e/tests/switchSave.feature",
      "beforeHooks": [],
      "afterHooks": [],
      "tests": [],
      "suites": [
        {
          "uuid": "c915e9d3-e339-4f14-8e7a-332db3e7da39",
          "title": "telnyx.com",
          "fullFile": "",
          "file": "",
          "beforeHooks": [],
          "afterHooks": [],
          "tests": [
            {
              "title": "A5 - Checking the ability to change data by slider",
              "fullTitle": "telnyx.com A5 - Checking the ability to change data by slider",
              "timedOut": null,
              "duration": 14592,
              "state": "passed",
              "speed": "slow",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {},
              "uuid": "122ee548-e81f-4150-8a6a-cd9cb07c6f94",
              "parentUUID": "c915e9d3-e339-4f14-8e7a-332db3e7da39",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "A6 - Checking the ability to change data and look at the current price",
              "fullTitle": "telnyx.com A6 - Checking the ability to change data and look at the current price",
              "timedOut": null,
              "duration": 10298,
              "state": "passed",
              "speed": "slow",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {},
              "uuid": "b37ea026-0bae-4815-9bfe-7dd671a6e7cb",
              "parentUUID": "c915e9d3-e339-4f14-8e7a-332db3e7da39",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "A7 - Checking the ability to see how much money will be save up",
              "fullTitle": "telnyx.com A7 - Checking the ability to see how much money will be save up",
              "timedOut": null,
              "duration": 10044,
              "state": "passed",
              "speed": "slow",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {},
              "uuid": "7322ee4c-f188-42df-9603-e019589e71ae",
              "parentUUID": "c915e9d3-e339-4f14-8e7a-332db3e7da39",
              "isHook": false,
              "skipped": false
            }
          ],
          "suites": [],
          "passes": [
            "122ee548-e81f-4150-8a6a-cd9cb07c6f94",
            "b37ea026-0bae-4815-9bfe-7dd671a6e7cb",
            "7322ee4c-f188-42df-9603-e019589e71ae"
          ],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 34934,
          "root": false,
          "rootEmpty": false,
          "_timeout": 2000
        }
      ],
      "passes": [],
      "failures": [],
      "pending": [],
      "skipped": [],
      "duration": 0,
      "root": true,
      "rootEmpty": true,
      "_timeout": 2000
    },
    {
      "uuid": "751b8c41-a163-4633-89d8-0a72a828acc8",
      "title": "",
      "fullFile": "cypress/e2e/tests/API.feature",
      "file": "cypress/e2e/tests/API.feature",
      "beforeHooks": [],
      "afterHooks": [],
      "tests": [],
      "suites": [
        {
          "uuid": "c2d030f7-27d6-4b89-acad-d42d61fd3f09",
          "title": "telnyx.com",
          "fullFile": "",
          "file": "",
          "beforeHooks": [],
          "afterHooks": [],
          "tests": [
            {
              "title": "A9 - Checking the ability to learn more about API documentation",
              "fullTitle": "telnyx.com A9 - Checking the ability to learn more about API documentation",
              "timedOut": null,
              "duration": 22539,
              "state": "passed",
              "speed": "slow",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {},
              "uuid": "1b3ee27c-351a-4b42-87e8-9c3e0df129ab",
              "parentUUID": "c2d030f7-27d6-4b89-acad-d42d61fd3f09",
              "isHook": false,
              "skipped": false
            }
          ],
          "suites": [],
          "passes": [
            "1b3ee27c-351a-4b42-87e8-9c3e0df129ab"
          ],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 22539,
          "root": false,
          "rootEmpty": false,
          "_timeout": 2000
        }
      ],
      "passes": [],
      "failures": [],
      "pending": [],
      "skipped": [],
      "duration": 0,
      "root": true,
      "rootEmpty": true,
      "_timeout": 2000
    },
    {
      "uuid": "964e3118-7f9c-4340-8927-c6b61c1e7aa7",
      "title": "",
      "fullFile": "cypress/e2e/tests/comments.feature",
      "file": "cypress/e2e/tests/comments.feature",
      "beforeHooks": [],
      "afterHooks": [],
      "tests": [],
      "suites": [
        {
          "uuid": "c880f6d0-4625-444c-be12-68fb2931e542",
          "title": "telnyx.com",
          "fullFile": "",
          "file": "",
          "beforeHooks": [],
          "afterHooks": [],
          "tests": [
            {
              "title": "A8 - Checking the ability to switch customers' comments",
              "fullTitle": "telnyx.com A8 - Checking the ability to switch customers' comments",
              "timedOut": null,
              "duration": 6149,
              "state": "passed",
              "speed": "medium",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {},
              "uuid": "5aeb0c01-9a36-458a-afde-13513c272275",
              "parentUUID": "c880f6d0-4625-444c-be12-68fb2931e542",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "A12 - Checking the ability to switch customers' comments",
              "fullTitle": "telnyx.com A12 - Checking the ability to switch customers' comments",
              "timedOut": null,
              "duration": 13725,
              "state": "passed",
              "speed": "slow",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {},
              "uuid": "dce06ce0-326f-48c3-841a-98cffad627ca",
              "parentUUID": "c880f6d0-4625-444c-be12-68fb2931e542",
              "isHook": false,
              "skipped": false
            }
          ],
          "suites": [],
          "passes": [
            "5aeb0c01-9a36-458a-afde-13513c272275",
            "dce06ce0-326f-48c3-841a-98cffad627ca"
          ],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 19874,
          "root": false,
          "rootEmpty": false,
          "_timeout": 2000
        }
      ],
      "passes": [],
      "failures": [],
      "pending": [],
      "skipped": [],
      "duration": 0,
      "root": true,
      "rootEmpty": true,
      "_timeout": 2000
    },
    {
      "uuid": "a5f61593-7fab-4399-82e8-0379dfae5136",
      "title": "",
      "fullFile": "cypress/e2e/tests/goToLogin.feature",
      "file": "cypress/e2e/tests/goToLogin.feature",
      "beforeHooks": [],
      "afterHooks": [],
      "tests": [],
      "suites": [
        {
          "uuid": "c374d3d2-3a65-470c-b907-cf183fc2ea34",
          "title": "telnyx.com",
          "fullFile": "",
          "file": "",
          "beforeHooks": [],
          "afterHooks": [],
          "tests": [
            {
              "title": "A11 - Checking the ability to go to the login page from the sign up page",
              "fullTitle": "telnyx.com A11 - Checking the ability to go to the login page from the sign up page",
              "timedOut": null,
              "duration": 37143,
              "state": "passed",
              "speed": "slow",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {},
              "uuid": "36ba8f2b-41c0-44d9-bb19-7209a2f686be",
              "parentUUID": "c374d3d2-3a65-470c-b907-cf183fc2ea34",
              "isHook": false,
              "skipped": false
            }
          ],
          "suites": [],
          "passes": [
            "36ba8f2b-41c0-44d9-bb19-7209a2f686be"
          ],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 37143,
          "root": false,
          "rootEmpty": false,
          "_timeout": 2000
        }
      ],
      "passes": [],
      "failures": [],
      "pending": [],
      "skipped": [],
      "duration": 0,
      "root": true,
      "rootEmpty": true,
      "_timeout": 2000
    },
    {
      "uuid": "28ffa421-89cb-4360-94ba-90597ab244d1",
      "title": "",
      "fullFile": "cypress/e2e/tests/goToSignUp.feature",
      "file": "cypress/e2e/tests/goToSignUp.feature",
      "beforeHooks": [],
      "afterHooks": [],
      "tests": [],
      "suites": [
        {
          "uuid": "91f6c403-d93a-41bc-93e9-f32bda83b7d5",
          "title": "telnyx.com",
          "fullFile": "",
          "file": "",
          "beforeHooks": [],
          "afterHooks": [],
          "tests": [
            {
              "title": "A10 - Checking the ability to go to the sign up page from the login page",
              "fullTitle": "telnyx.com A10 - Checking the ability to go to the sign up page from the login page",
              "timedOut": null,
              "duration": 51491,
              "state": "passed",
              "speed": "slow",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {},
              "uuid": "1ac7c58c-eda3-44c7-adcc-3b3aed66aba5",
              "parentUUID": "91f6c403-d93a-41bc-93e9-f32bda83b7d5",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "A14 - Checking the ability to go to the sign up page from footer",
              "fullTitle": "telnyx.com A14 - Checking the ability to go to the sign up page from footer",
              "timedOut": null,
              "duration": 17194,
              "state": "passed",
              "speed": "slow",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {},
              "uuid": "e8c127b9-e5e1-40c8-b9e4-579496e6ae7a",
              "parentUUID": "91f6c403-d93a-41bc-93e9-f32bda83b7d5",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "A13 - Checking the ability to go to the sign up page from 'Switch + Save with Tenlyx' section",
              "fullTitle": "telnyx.com A13 - Checking the ability to go to the sign up page from 'Switch + Save with Tenlyx' section",
              "timedOut": null,
              "duration": 22252,
              "state": "passed",
              "speed": "slow",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {},
              "uuid": "f746521d-9f57-488c-8fab-87b51e12eefa",
              "parentUUID": "91f6c403-d93a-41bc-93e9-f32bda83b7d5",
              "isHook": false,
              "skipped": false
            }
          ],
          "suites": [],
          "passes": [
            "1ac7c58c-eda3-44c7-adcc-3b3aed66aba5",
            "e8c127b9-e5e1-40c8-b9e4-579496e6ae7a",
            "f746521d-9f57-488c-8fab-87b51e12eefa"
          ],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 90937,
          "root": false,
          "rootEmpty": false,
          "_timeout": 2000
        }
      ],
      "passes": [],
      "failures": [],
      "pending": [],
      "skipped": [],
      "duration": 0,
      "root": true,
      "rootEmpty": true,
      "_timeout": 2000
    },
    {
      "uuid": "534a1ef0-9430-4340-9baf-2ff9af4e3e94",
      "title": "",
      "fullFile": "cypress/e2e/tests/products.feature",
      "file": "cypress/e2e/tests/products.feature",
      "beforeHooks": [],
      "afterHooks": [],
      "tests": [],
      "suites": [
        {
          "uuid": "217cf3fb-5406-483d-9e4c-04a1aff3aace",
          "title": "telnyx.com",
          "fullFile": "",
          "file": "",
          "beforeHooks": [],
          "afterHooks": [],
          "tests": [
            {
              "title": "A1 - Checking that it is possible to see all products by menu",
              "fullTitle": "telnyx.com A1 - Checking that it is possible to see all products by menu",
              "timedOut": null,
              "duration": 22415,
              "state": "passed",
              "speed": "slow",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {},
              "uuid": "c0948662-285a-41e5-a963-b85e8a7c7fd9",
              "parentUUID": "217cf3fb-5406-483d-9e4c-04a1aff3aace",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "A2 - Checking that it is possible to see all products by the main page",
              "fullTitle": "telnyx.com A2 - Checking that it is possible to see all products by the main page",
              "timedOut": null,
              "duration": 15601,
              "state": "passed",
              "speed": "slow",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {},
              "uuid": "a30adfb7-9a2d-4df6-9464-3c61a52f01ed",
              "parentUUID": "217cf3fb-5406-483d-9e4c-04a1aff3aace",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "A3 - Checking that it is possible to see all products by the footer",
              "fullTitle": "telnyx.com A3 - Checking that it is possible to see all products by the footer",
              "timedOut": null,
              "duration": 13934,
              "state": "passed",
              "speed": "slow",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {},
              "uuid": "5fb8d1f1-a316-4187-81ed-fa5a0efb7153",
              "parentUUID": "217cf3fb-5406-483d-9e4c-04a1aff3aace",
              "isHook": false,
              "skipped": false
            }
          ],
          "suites": [],
          "passes": [
            "c0948662-285a-41e5-a963-b85e8a7c7fd9",
            "a30adfb7-9a2d-4df6-9464-3c61a52f01ed",
            "5fb8d1f1-a316-4187-81ed-fa5a0efb7153"
          ],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 51950,
          "root": false,
          "rootEmpty": false,
          "_timeout": 2000
        }
      ],
      "passes": [],
      "failures": [],
      "pending": [],
      "skipped": [],
      "duration": 0,
      "root": true,
      "rootEmpty": true,
      "_timeout": 2000
    },
    {
      "uuid": "1427b952-b59b-4ff9-bb9e-678d2d1ee694",
      "title": "",
      "fullFile": "cypress/e2e/tests/story.feature",
      "file": "cypress/e2e/tests/story.feature",
      "beforeHooks": [],
      "afterHooks": [],
      "tests": [],
      "suites": [
        {
          "uuid": "56d8330d-238f-4057-b10b-a41fd6532311",
          "title": "telnyx.com",
          "fullFile": "",
          "file": "",
          "beforeHooks": [],
          "afterHooks": [],
          "tests": [
            {
              "title": "A4 - Checking the ability to read customers stories",
              "fullTitle": "telnyx.com A4 - Checking the ability to read customers stories",
              "timedOut": null,
              "duration": 13698,
              "state": "passed",
              "speed": "slow",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {},
              "uuid": "2f9aa923-731c-43d7-9aca-0ee8bebf611e",
              "parentUUID": "56d8330d-238f-4057-b10b-a41fd6532311",
              "isHook": false,
              "skipped": false
            }
          ],
          "suites": [],
          "passes": [
            "2f9aa923-731c-43d7-9aca-0ee8bebf611e"
          ],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 13698,
          "root": false,
          "rootEmpty": false,
          "_timeout": 2000
        }
      ],
      "passes": [],
      "failures": [],
      "pending": [],
      "skipped": [],
      "duration": 0,
      "root": true,
      "rootEmpty": true,
      "_timeout": 2000
    },
    {
      "uuid": "465ff876-ce33-4f87-8059-09d7f69eb9de",
      "title": "",
      "fullFile": "cypress/e2e/tests/switchSave.feature",
      "file": "cypress/e2e/tests/switchSave.feature",
      "beforeHooks": [],
      "afterHooks": [],
      "tests": [],
      "suites": [
        {
          "uuid": "1e843f70-9f99-4336-8f98-6cf054865dae",
          "title": "telnyx.com",
          "fullFile": "",
          "file": "",
          "beforeHooks": [],
          "afterHooks": [],
          "tests": [
            {
              "title": "A5 - Checking the ability to change data by slider",
              "fullTitle": "telnyx.com A5 - Checking the ability to change data by slider",
              "timedOut": null,
              "duration": 31894,
              "state": "passed",
              "speed": "slow",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {},
              "uuid": "1fba63a0-d98e-4aaa-83f4-88d1d8c19dde",
              "parentUUID": "1e843f70-9f99-4336-8f98-6cf054865dae",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "A6 - Checking the ability to change data and look at the current price",
              "fullTitle": "telnyx.com A6 - Checking the ability to change data and look at the current price",
              "timedOut": null,
              "duration": 29212,
              "state": "passed",
              "speed": "slow",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {},
              "uuid": "9de7f74f-b4a5-434f-b0c1-f0f2d47fa619",
              "parentUUID": "1e843f70-9f99-4336-8f98-6cf054865dae",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "A7 - Checking the ability to see how much money will be save up",
              "fullTitle": "telnyx.com A7 - Checking the ability to see how much money will be save up",
              "timedOut": null,
              "duration": 28936,
              "state": "passed",
              "speed": "slow",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {},
              "uuid": "668e7e82-c644-479d-824f-3ac93989407f",
              "parentUUID": "1e843f70-9f99-4336-8f98-6cf054865dae",
              "isHook": false,
              "skipped": false
            }
          ],
          "suites": [],
          "passes": [
            "1fba63a0-d98e-4aaa-83f4-88d1d8c19dde",
            "9de7f74f-b4a5-434f-b0c1-f0f2d47fa619",
            "668e7e82-c644-479d-824f-3ac93989407f"
          ],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 90042,
          "root": false,
          "rootEmpty": false,
          "_timeout": 2000
        }
      ],
      "passes": [],
      "failures": [],
      "pending": [],
      "skipped": [],
      "duration": 0,
      "root": true,
      "rootEmpty": true,
      "_timeout": 2000
    },
    {
      "uuid": "225f8a51-58c8-4c2b-afc6-4bd106df6fcb",
      "title": "",
      "fullFile": "cypress/e2e/tests/twitter.feature",
      "file": "cypress/e2e/tests/twitter.feature",
      "beforeHooks": [],
      "afterHooks": [],
      "tests": [],
      "suites": [
        {
          "uuid": "95eeccc0-ae13-4faf-b34f-ddded7245ce7",
          "title": "telnyx.com",
          "fullFile": "",
          "file": "",
          "beforeHooks": [],
          "afterHooks": [],
          "tests": [
            {
              "title": "A15 -  Check that the site is linked with Twitter",
              "fullTitle": "telnyx.com A15 -  Check that the site is linked with Twitter",
              "timedOut": null,
              "duration": 15457,
              "state": "passed",
              "speed": "slow",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {},
              "uuid": "508ed654-d18d-4c26-9d9a-5e8d24cba78b",
              "parentUUID": "95eeccc0-ae13-4faf-b34f-ddded7245ce7",
              "isHook": false,
              "skipped": false
            }
          ],
          "suites": [],
          "passes": [
            "508ed654-d18d-4c26-9d9a-5e8d24cba78b"
          ],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 15457,
          "root": false,
          "rootEmpty": false,
          "_timeout": 2000
        }
      ],
      "passes": [],
      "failures": [],
      "pending": [],
      "skipped": [],
      "duration": 0,
      "root": true,
      "rootEmpty": true,
      "_timeout": 2000
    },
    {
      "uuid": "c7842234-998c-498a-8765-e28e03790c9d",
      "title": "",
      "fullFile": "cypress/e2e/tests/API.feature",
      "file": "cypress/e2e/tests/API.feature",
      "beforeHooks": [],
      "afterHooks": [],
      "tests": [],
      "suites": [
        {
          "uuid": "5fb19a84-91f3-4168-8b8e-1af87ffa5f35",
          "title": "telnyx.com",
          "fullFile": "",
          "file": "",
          "beforeHooks": [],
          "afterHooks": [],
          "tests": [
            {
              "title": "A9 - Checking the ability to learn more about API documentation",
              "fullTitle": "telnyx.com A9 - Checking the ability to learn more about API documentation",
              "timedOut": null,
              "duration": 13982,
              "state": "passed",
              "speed": "slow",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {},
              "uuid": "4d082adb-203c-47bf-8942-7387841e9f17",
              "parentUUID": "5fb19a84-91f3-4168-8b8e-1af87ffa5f35",
              "isHook": false,
              "skipped": false
            }
          ],
          "suites": [],
          "passes": [
            "4d082adb-203c-47bf-8942-7387841e9f17"
          ],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 13982,
          "root": false,
          "rootEmpty": false,
          "_timeout": 2000
        }
      ],
      "passes": [],
      "failures": [],
      "pending": [],
      "skipped": [],
      "duration": 0,
      "root": true,
      "rootEmpty": true,
      "_timeout": 2000
    },
    {
      "uuid": "7bfdc073-4ece-45e3-be25-43eaf621cfa9",
      "title": "",
      "fullFile": "cypress/e2e/tests/comments.feature",
      "file": "cypress/e2e/tests/comments.feature",
      "beforeHooks": [],
      "afterHooks": [],
      "tests": [],
      "suites": [
        {
          "uuid": "bcae8a9d-3e85-4908-a416-1d7f726bfdd4",
          "title": "telnyx.com",
          "fullFile": "",
          "file": "",
          "beforeHooks": [],
          "afterHooks": [],
          "tests": [
            {
              "title": "A8 - Checking the ability to switch customers' comments",
              "fullTitle": "telnyx.com A8 - Checking the ability to switch customers' comments",
              "timedOut": null,
              "duration": 4912,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {},
              "uuid": "7ea52a13-fc56-4dd2-8767-363108f909f1",
              "parentUUID": "bcae8a9d-3e85-4908-a416-1d7f726bfdd4",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "A12 - Checking the ability to switch customers' comments",
              "fullTitle": "telnyx.com A12 - Checking the ability to switch customers' comments",
              "timedOut": null,
              "duration": 11554,
              "state": "passed",
              "speed": "slow",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {},
              "uuid": "61417ef2-7f8f-4499-b261-c032e90df945",
              "parentUUID": "bcae8a9d-3e85-4908-a416-1d7f726bfdd4",
              "isHook": false,
              "skipped": false
            }
          ],
          "suites": [],
          "passes": [
            "7ea52a13-fc56-4dd2-8767-363108f909f1",
            "61417ef2-7f8f-4499-b261-c032e90df945"
          ],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 16466,
          "root": false,
          "rootEmpty": false,
          "_timeout": 2000
        }
      ],
      "passes": [],
      "failures": [],
      "pending": [],
      "skipped": [],
      "duration": 0,
      "root": true,
      "rootEmpty": true,
      "_timeout": 2000
    },
    {
      "uuid": "7128c7a3-4ff3-4ea5-a2e5-09ee6ed715bf",
      "title": "",
      "fullFile": "cypress/e2e/tests/goToLogin.feature",
      "file": "cypress/e2e/tests/goToLogin.feature",
      "beforeHooks": [],
      "afterHooks": [],
      "tests": [],
      "suites": [
        {
          "uuid": "b3fbb53a-5ebd-4a66-b343-2e089eaf9fb4",
          "title": "telnyx.com",
          "fullFile": "",
          "file": "",
          "beforeHooks": [],
          "afterHooks": [],
          "tests": [
            {
              "title": "A11 - Checking the ability to go to the login page from the sign up page",
              "fullTitle": "telnyx.com A11 - Checking the ability to go to the login page from the sign up page",
              "timedOut": null,
              "duration": 28239,
              "state": "passed",
              "speed": "slow",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {},
              "uuid": "fc71d00e-e62f-4296-9330-9cecc41d9e9d",
              "parentUUID": "b3fbb53a-5ebd-4a66-b343-2e089eaf9fb4",
              "isHook": false,
              "skipped": false
            }
          ],
          "suites": [],
          "passes": [
            "fc71d00e-e62f-4296-9330-9cecc41d9e9d"
          ],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 28239,
          "root": false,
          "rootEmpty": false,
          "_timeout": 2000
        }
      ],
      "passes": [],
      "failures": [],
      "pending": [],
      "skipped": [],
      "duration": 0,
      "root": true,
      "rootEmpty": true,
      "_timeout": 2000
    },
    {
      "uuid": "a22c24e0-5648-4be5-9996-46d51b24432e",
      "title": "",
      "fullFile": "cypress/e2e/tests/goToSignUp.feature",
      "file": "cypress/e2e/tests/goToSignUp.feature",
      "beforeHooks": [],
      "afterHooks": [],
      "tests": [],
      "suites": [
        {
          "uuid": "a00c69e8-659c-46d8-8771-9486b47252e0",
          "title": "telnyx.com",
          "fullFile": "",
          "file": "",
          "beforeHooks": [],
          "afterHooks": [],
          "tests": [
            {
              "title": "A10 - Checking the ability to go to the sign up page from the login page",
              "fullTitle": "telnyx.com A10 - Checking the ability to go to the sign up page from the login page",
              "timedOut": null,
              "duration": 27124,
              "state": "passed",
              "speed": "slow",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {},
              "uuid": "ffd1ceaa-4767-47b0-9254-a3cec2bf4ab7",
              "parentUUID": "a00c69e8-659c-46d8-8771-9486b47252e0",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "A14 - Checking the ability to go to the sign up page from footer",
              "fullTitle": "telnyx.com A14 - Checking the ability to go to the sign up page from footer",
              "timedOut": null,
              "duration": 6853,
              "state": "passed",
              "speed": "medium",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {},
              "uuid": "09bd7c6c-4c6a-4983-9208-e8d7f0b2e49d",
              "parentUUID": "a00c69e8-659c-46d8-8771-9486b47252e0",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "A13 - Checking the ability to go to the sign up page from 'Switch + Save with Tenlyx' section",
              "fullTitle": "telnyx.com A13 - Checking the ability to go to the sign up page from 'Switch + Save with Tenlyx' section",
              "timedOut": null,
              "duration": 12074,
              "state": "passed",
              "speed": "slow",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {},
              "uuid": "c0a5fa06-5df6-420d-b118-ff6bf5477b41",
              "parentUUID": "a00c69e8-659c-46d8-8771-9486b47252e0",
              "isHook": false,
              "skipped": false
            }
          ],
          "suites": [],
          "passes": [
            "ffd1ceaa-4767-47b0-9254-a3cec2bf4ab7",
            "09bd7c6c-4c6a-4983-9208-e8d7f0b2e49d",
            "c0a5fa06-5df6-420d-b118-ff6bf5477b41"
          ],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 46051,
          "root": false,
          "rootEmpty": false,
          "_timeout": 2000
        }
      ],
      "passes": [],
      "failures": [],
      "pending": [],
      "skipped": [],
      "duration": 0,
      "root": true,
      "rootEmpty": true,
      "_timeout": 2000
    },
    {
      "uuid": "9dc400bc-1fcc-4991-b251-5f3b36fdfabe",
      "title": "",
      "fullFile": "cypress/e2e/tests/products.feature",
      "file": "cypress/e2e/tests/products.feature",
      "beforeHooks": [],
      "afterHooks": [],
      "tests": [],
      "suites": [
        {
          "uuid": "0f0b7d36-d735-4920-86ed-100d0fdb5e58",
          "title": "telnyx.com",
          "fullFile": "",
          "file": "",
          "beforeHooks": [],
          "afterHooks": [],
          "tests": [
            {
              "title": "A1 - Checking that it is possible to see all products by menu",
              "fullTitle": "telnyx.com A1 - Checking that it is possible to see all products by menu",
              "timedOut": null,
              "duration": 9154,
              "state": "passed",
              "speed": "medium",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {},
              "uuid": "671072b8-04b7-4695-8006-5859c899141a",
              "parentUUID": "0f0b7d36-d735-4920-86ed-100d0fdb5e58",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "A2 - Checking that it is possible to see all products by the main page",
              "fullTitle": "telnyx.com A2 - Checking that it is possible to see all products by the main page",
              "timedOut": null,
              "duration": 6040,
              "state": "passed",
              "speed": "medium",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {},
              "uuid": "53ac72cb-d810-4950-b4b2-720e8115ddb0",
              "parentUUID": "0f0b7d36-d735-4920-86ed-100d0fdb5e58",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "A3 - Checking that it is possible to see all products by the footer",
              "fullTitle": "telnyx.com A3 - Checking that it is possible to see all products by the footer",
              "timedOut": null,
              "duration": 5492,
              "state": "passed",
              "speed": "medium",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {},
              "uuid": "62509c81-38b2-43de-9f92-4b387f53f7c2",
              "parentUUID": "0f0b7d36-d735-4920-86ed-100d0fdb5e58",
              "isHook": false,
              "skipped": false
            }
          ],
          "suites": [],
          "passes": [
            "671072b8-04b7-4695-8006-5859c899141a",
            "53ac72cb-d810-4950-b4b2-720e8115ddb0",
            "62509c81-38b2-43de-9f92-4b387f53f7c2"
          ],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 20686,
          "root": false,
          "rootEmpty": false,
          "_timeout": 2000
        }
      ],
      "passes": [],
      "failures": [],
      "pending": [],
      "skipped": [],
      "duration": 0,
      "root": true,
      "rootEmpty": true,
      "_timeout": 2000
    },
    {
      "uuid": "61902d4e-6ee0-474e-891f-7ed8582bc27f",
      "title": "",
      "fullFile": "cypress/e2e/tests/story.feature",
      "file": "cypress/e2e/tests/story.feature",
      "beforeHooks": [],
      "afterHooks": [],
      "tests": [],
      "suites": [
        {
          "uuid": "3eddf219-c073-459e-b91f-c3985e8f6125",
          "title": "telnyx.com",
          "fullFile": "",
          "file": "",
          "beforeHooks": [],
          "afterHooks": [],
          "tests": [
            {
              "title": "A4 - Checking the ability to read customers stories",
              "fullTitle": "telnyx.com A4 - Checking the ability to read customers stories",
              "timedOut": null,
              "duration": 6656,
              "state": "passed",
              "speed": "medium",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {},
              "uuid": "bdd0232a-0544-445f-8461-ee991e0dc96c",
              "parentUUID": "3eddf219-c073-459e-b91f-c3985e8f6125",
              "isHook": false,
              "skipped": false
            }
          ],
          "suites": [],
          "passes": [
            "bdd0232a-0544-445f-8461-ee991e0dc96c"
          ],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 6656,
          "root": false,
          "rootEmpty": false,
          "_timeout": 2000
        }
      ],
      "passes": [],
      "failures": [],
      "pending": [],
      "skipped": [],
      "duration": 0,
      "root": true,
      "rootEmpty": true,
      "_timeout": 2000
    },
    {
      "uuid": "16e2f3f8-e584-403b-89a1-e88e07911234",
      "title": "",
      "fullFile": "cypress/e2e/tests/switchSave.feature",
      "file": "cypress/e2e/tests/switchSave.feature",
      "beforeHooks": [],
      "afterHooks": [],
      "tests": [],
      "suites": [
        {
          "uuid": "46d16481-25ba-4ad6-af60-4e461b5fa658",
          "title": "telnyx.com",
          "fullFile": "",
          "file": "",
          "beforeHooks": [],
          "afterHooks": [],
          "tests": [
            {
              "title": "A5 - Checking the ability to change data by slider",
              "fullTitle": "telnyx.com A5 - Checking the ability to change data by slider",
              "timedOut": null,
              "duration": 10989,
              "state": "passed",
              "speed": "slow",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {},
              "uuid": "b7a8c3dd-13fb-472d-86cd-cc3521d26a5e",
              "parentUUID": "46d16481-25ba-4ad6-af60-4e461b5fa658",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "A6 - Checking the ability to change data and look at the current price",
              "fullTitle": "telnyx.com A6 - Checking the ability to change data and look at the current price",
              "timedOut": null,
              "duration": 13268,
              "state": "passed",
              "speed": "slow",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {},
              "uuid": "24f0d85e-40c1-4c13-a17a-41365392128b",
              "parentUUID": "46d16481-25ba-4ad6-af60-4e461b5fa658",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "A7 - Checking the ability to see how much money will be save up",
              "fullTitle": "telnyx.com A7 - Checking the ability to see how much money will be save up",
              "timedOut": null,
              "duration": 12969,
              "state": "passed",
              "speed": "slow",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {},
              "uuid": "8c626147-58a7-4387-a766-fe9a8521f513",
              "parentUUID": "46d16481-25ba-4ad6-af60-4e461b5fa658",
              "isHook": false,
              "skipped": false
            }
          ],
          "suites": [],
          "passes": [
            "b7a8c3dd-13fb-472d-86cd-cc3521d26a5e",
            "24f0d85e-40c1-4c13-a17a-41365392128b",
            "8c626147-58a7-4387-a766-fe9a8521f513"
          ],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 37226,
          "root": false,
          "rootEmpty": false,
          "_timeout": 2000
        }
      ],
      "passes": [],
      "failures": [],
      "pending": [],
      "skipped": [],
      "duration": 0,
      "root": true,
      "rootEmpty": true,
      "_timeout": 2000
    },
    {
      "uuid": "fb82c24c-a5b9-405c-bfce-3673be346f04",
      "title": "",
      "fullFile": "cypress/e2e/tests/twitter.feature",
      "file": "cypress/e2e/tests/twitter.feature",
      "beforeHooks": [],
      "afterHooks": [],
      "tests": [],
      "suites": [
        {
          "uuid": "c0f4a8ff-b0b3-491d-8b03-2fa225af0289",
          "title": "telnyx.com",
          "fullFile": "",
          "file": "",
          "beforeHooks": [],
          "afterHooks": [],
          "tests": [
            {
              "title": "A15 -  Check that the site is linked with Twitter",
              "fullTitle": "telnyx.com A15 -  Check that the site is linked with Twitter",
              "timedOut": null,
              "duration": 4946,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\n(0, registry_1.assignRegistry)(registry);\nmessages.stack.push({\n    testCaseStarted: {\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_helpers_1.createTimestamp)(),\n    },\n});\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() => {\n            delete window.testState.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: hook.keyword,\n                message: \"\",\n            });\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, hook.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            registry.runHook(this, hook);\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const end = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepFinished: {\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: Status.Passed,\n                        duration: (0, messages_helpers_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                },\n            });\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \"Expected pickle step to have a text\");\n        const scenarioStep = (0, assertions_1.assertAndReturn)(astIdMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \"Expected to find at least one astNodeId\")), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        cy.then(() => {\n            window.testState.pickleStep = step.pickleStep;\n            Cypress.log({\n                name: \"step\",\n                displayName: (0, assertions_1.assertAndReturn)(\"keyword\" in scenarioStep && scenarioStep.keyword, \"Expected to find a keyword in the scenario step\"),\n                message: text,\n            });\n        });\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() => {\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_helpers_1.createTimestamp)();\n            messages.stack.push({\n                testStepStarted: {\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                },\n            });\n            if (messages.enabled) {\n                cy.task(constants_1.TASK_TEST_STEP_STARTED, pickleStep.id, { log: false });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) => {\n            const ensureChain = (value) => Cypress.isCy(value) ? value : cy.wrap(value, { log: false });\n            try {\n                return ensureChain(registry.runStepDefininition(this, text, argument)).then((result) => {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) => {\n            var _a, _b, _c;\n            const end = (0, messages_helpers_1.createTimestamp)();\n            if (result === \"pending\") {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Pending,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n                for (const skippedStep of remainingSteps) {\n                    const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \"Expected a step to either be a hook or a pickleStep\");\n                    messages.stack.push({\n                        testStepStarted: {\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                    messages.stack.push({\n                        testStepFinished: {\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: Status.Skipped,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_helpers_1.createTimestamp)(),\n                        },\n                    });\n                }\n                for (let i = 0, count = remainingSteps.length; i < count; i++) {\n                    remainingSteps.pop();\n                }\n                this.skip();\n            }\n            else {\n                messages.stack.push({\n                    testStepFinished: {\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: Status.Passed,\n                            duration: (0, messages_helpers_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    },\n                });\n                remainingSteps.shift();\n            }\n        });\n    }\n}",
              "err": {},
              "uuid": "b186e99d-0b7e-4cff-973b-976c3ba8f1e2",
              "parentUUID": "c0f4a8ff-b0b3-491d-8b03-2fa225af0289",
              "isHook": false,
              "skipped": false
            }
          ],
          "suites": [],
          "passes": [
            "b186e99d-0b7e-4cff-973b-976c3ba8f1e2"
          ],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 4946,
          "root": false,
          "rootEmpty": false,
          "_timeout": 2000
        }
      ],
      "passes": [],
      "failures": [],
      "pending": [],
      "skipped": [],
      "duration": 0,
      "root": true,
      "rootEmpty": true,
      "_timeout": 2000
    }
  ],
  "meta": {
    "mocha": {
      "version": "7.0.1"
    },
    "mochawesome": {
      "options": {
        "quiet": false,
        "reportFilename": "mochawesome",
        "saveHtml": false,
        "saveJson": true,
        "consoleReporter": "spec",
        "useInlineDiffs": false,
        "code": true
      },
      "version": "7.1.3"
    },
    "marge": {
      "options": {
        "id": "default",
        "reportDir": "cypress/results/json",
        "overwrite": true,
        "html": false,
        "json": true
      },
      "version": "6.2.0"
    }
  }
}